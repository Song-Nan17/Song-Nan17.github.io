<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>this, call(), apply() 和bind() | 宋博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="对于this，以前只是在定义一个指定类型的对象一节，了解到this就是代码运行时的对象，指向调用函数的对象。周六的测评有道this和箭头函数的题，以及最后一道题call, apply和bind方法，都和this指向有。 this 指向##全局环境下在全局环境下，this 始终指向全局对象（window）, 无论是否严格模式；1234567console.log(this.document ===">
<meta property="og:type" content="article">
<meta property="og:title" content="this, call(), apply() 和bind()">
<meta property="og:url" content="http://yoursite.com/2019/01/20/notes_of_this/index.html">
<meta property="og:site_name" content="宋博客">
<meta property="og:description" content="对于this，以前只是在定义一个指定类型的对象一节，了解到this就是代码运行时的对象，指向调用函数的对象。周六的测评有道this和箭头函数的题，以及最后一道题call, apply和bind方法，都和this指向有。 this 指向##全局环境下在全局环境下，this 始终指向全局对象（window）, 无论是否严格模式；1234567console.log(this.document ===">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a85d55ddly1fzdkwttbj6j2084087dft.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a85d55ddly1fzdl7sy5hfj20dm06qmx4.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a85d55ddly1fzdltxlz62j20bv0a6aa7.jpg">
<meta property="og:image" content="http://ww1.sinaimg.cn/large/a85d55ddly1fzdmexhrrsj20og0aidgi.jpg">
<meta property="og:updated_time" content="2019-01-20T18:40:35.371Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="this, call(), apply() 和bind()">
<meta name="twitter:description" content="对于this，以前只是在定义一个指定类型的对象一节，了解到this就是代码运行时的对象，指向调用函数的对象。周六的测评有道this和箭头函数的题，以及最后一道题call, apply和bind方法，都和this指向有。 this 指向##全局环境下在全局环境下，this 始终指向全局对象（window）, 无论是否严格模式；1234567console.log(this.document ===">
<meta name="twitter:image" content="http://ww1.sinaimg.cn/large/a85d55ddly1fzdkwttbj6j2084087dft.jpg">
  
    <link rel="alternate" href="/atom.xml" title="宋博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">宋博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">我爱学习</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-notes_of_this" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/20/notes_of_this/" class="article-date">
  <time datetime="2019-01-20T14:56:13.826Z" itemprop="datePublished">2019-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      this, call(), apply() 和bind()
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于<code>this</code>，以前只是在定义一个指定类型的对象一节，了解到<code>this</code>就是代码运行时的对象，指向调用函数的对象。周六的测评有道<code>this</code>和箭头函数的题，以及最后一道题<code>call</code>, <code>apply</code>和<code>bind</code>方法，都和<code>this</code>指向有。</p>
<h1 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h1><p>##全局环境下<br>在全局环境下，<code>this</code> 始终指向全局对象（<code>window</code>）, 无论是否严格模式；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(this.document === document); // true</span><br><span class="line"></span><br><span class="line">// 在浏览器中，全局对象为 window 对象：</span><br><span class="line">console.log(this === window); // true</span><br><span class="line"></span><br><span class="line">this.a = 37;</span><br><span class="line">console.log(window.a); // 37</span><br></pre></td></tr></table></figure></p>
<h2 id="函数上下文调用"><a href="#函数上下文调用" class="headerlink" title="函数上下文调用"></a>函数上下文调用</h2><h3 id="函数直接调用"><a href="#函数直接调用" class="headerlink" title="函数直接调用"></a>函数直接调用</h3><p>普通函数内部的<code>this</code>分两种情况，<strong>严格模式</strong>和<strong>非严格模式</strong>。</p>
<ul>
<li><p>非严格模式下，<code>this</code> 默认指向全局对象<code>window</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1() === window; // true</span><br></pre></td></tr></table></figure>
</li>
<li><p>严格模式下， <code>this</code>为<code>undefined</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f2()&#123;</span><br><span class="line">  &quot;use strict&quot;; // 这里是严格模式</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2() === undefined; // true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="对象中的this"><a href="#对象中的this" class="headerlink" title="对象中的this"></a>对象中的this</h3><p>对象内部方法的<code>this</code>指向<strong>调用这些方法的对象</strong></p>
<ol>
<li>函数的定义位置不影响其<code>this</code>指向，<code>this</code>指向只和调用函数的对象有关。</li>
<li>多层嵌套的对象，内部方法的<code>this</code>指向离被调用函数最近的对象（window也是对象，其内部对象调用方法的this指向内部对象， 而非window）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//1</span><br><span class="line"></span><br><span class="line">var o = &#123;</span><br><span class="line">  prop: 37,</span><br><span class="line">  f: function() &#123;</span><br><span class="line">    return this.prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(o.f());  //37</span><br><span class="line">var a = o.f;</span><br><span class="line">console.log(a()):  //undefined</span><br><span class="line"></span><br><span class="line">var o = &#123;prop: 37&#125;;</span><br><span class="line"></span><br><span class="line">function independent() &#123;</span><br><span class="line">  return this.prop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f = independent;</span><br><span class="line"></span><br><span class="line">console.log(o.f()); // 37</span><br><span class="line"></span><br><span class="line">//2</span><br><span class="line"></span><br><span class="line">o.b = &#123;</span><br><span class="line">  g: independent,</span><br><span class="line">  prop: 42</span><br><span class="line">&#125;;</span><br><span class="line">console.log(o.b.g()); // 42</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="原型链中this"><a href="#原型链中this" class="headerlink" title="原型链中this"></a>原型链中this</h3><p>原型链中的方法的<code>this</code>仍然指向调用它的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  f : function()&#123; </span><br><span class="line">    return this.a + this.b; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var p = Object.create(o);</span><br><span class="line">p.a = 1;</span><br><span class="line">p.b = 4;</span><br><span class="line"></span><br><span class="line">console.log(p.f()); // 5</span><br></pre></td></tr></table></figure></p>
<p>在<code>p</code>中没有属性<code>f</code>，当执行<code>p.f()</code>时，会查找<code>p</code>的原型链，找到<code>f</code> 函数并执行，但函数内部<code>this</code>指向对象 <code>p</code>,只需记住谁调用指向谁。</p>
<ul>
<li>以上对于函数作为<code>getter</code> &amp; <code>setter</code> 调用时同样适用。(<strong>后续再去了解</strong>)</li>
</ul>
<h3 id="构造函数中this"><a href="#构造函数中this" class="headerlink" title="构造函数中this"></a>构造函数中this</h3><p>构造函数中的<code>this</code>与被创建的新对象绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function C()&#123;</span><br><span class="line">  this.a = 37;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = new C();</span><br><span class="line">console.log(o.a); // 37 o = C &#123;a:37&#125;</span><br><span class="line"></span><br><span class="line">function C2()&#123;</span><br><span class="line">  this.a = 37;</span><br><span class="line">  return &#123;a:38&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = new C2();</span><br><span class="line">console.log(b.a); // 38 b=&#123;a:38&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="call-amp-apply"><a href="#call-amp-apply" class="headerlink" title="call &amp; apply"></a>call &amp; apply</h3><p>当函数通过Function对象的原型中继承的方法<code>call()</code> 和 <code>apply()</code> 方法调用时， 其函数内部的<code>this</code>值可绑定到 <code>call()</code> &amp; <code>apply()</code> 方法指定的第一个对象上， 如果第一个参数不是对象，JavaScript内部会尝试将其转换成对象然后指向它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function add(c, d)&#123;</span><br><span class="line">  return this.a + this.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = &#123;a:1, b:3&#125;;</span><br><span class="line"></span><br><span class="line">add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16</span><br><span class="line"></span><br><span class="line">add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34</span><br><span class="line"></span><br><span class="line">function tt() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">// 返回对象见下图</span><br><span class="line">tt.call(5);  </span><br><span class="line">tt.call(&apos;asd&apos;);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://ww1.sinaimg.cn/large/a85d55ddly1fzdkwttbj6j2084087dft.jpg" alt=""></p>
<h3 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a>bind 方法</h3><p><code>bind</code>方法在ES5引入， 在<code>Function</code>的原型链上， <code>Function.prototype.bind</code>。通过<code>bind</code>方法绑定后， 函数将被永远绑定在其第一个参数对象上， 而无论其在什么情况下被调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">  return this.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = f.bind(&#123;a:&quot;azerty&quot;&#125;);</span><br><span class="line">console.log(g()); // azerty</span><br><span class="line"></span><br><span class="line">var o = &#123;a:37, f:f, g:g&#125;;</span><br><span class="line">console.log(o.f(), o.g()); // 37, azerty</span><br></pre></td></tr></table></figure></p>
<h3 id="DOM-事件处理函数中的-this-amp-内联事件中的-this-后续再使用html实例理解"><a href="#DOM-事件处理函数中的-this-amp-内联事件中的-this-后续再使用html实例理解" class="headerlink" title="DOM 事件处理函数中的 this &amp; 内联事件中的 this(后续再使用html实例理解)"></a>DOM 事件处理函数中的 this &amp; 内联事件中的 this(后续再使用html实例理解)</h3><ul>
<li>DOM事件处理函数</li>
</ul>
<p>当函数被当做监听事件处理函数时， 其 <code>this</code> 指向触发该事件的元素 （针对于<code>addEventListener</code>事件）</p>
<ul>
<li><p>内联事件<br>内联事件中的<code>this</code>指向分两种情况：</p>
<ul>
<li>当代码被内联处理函数调用时，它的<code>this</code>指向监听器所在的DOM元素</li>
<li>当代码被包括在函数内部执行时，其<code>this</code>指向等同于 <strong>函数直接调用</strong>的情况，即在非严格模式指向全局对象<code>window</code>， 在严格模式指向<code>undefined</code><h3 id="setTimeout-amp-setInterval"><a href="#setTimeout-amp-setInterval" class="headerlink" title="setTimeout &amp; setInterval"></a>setTimeout &amp; setInterval</h3>对于延时函数内部的回调函数的<code>this</code>指向全局对象<code>window</code>（可以通过<code>bind</code>方法改变其内部函数的this指向）<br>看下边代码及截图<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//默认情况下代码</span><br><span class="line">function Person() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();//3秒后返回 window 对象</span><br><span class="line">==============================================</span><br><span class="line">//通过bind绑定</span><br><span class="line">function Person() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setTimeout((function() &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;).bind(this), 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();//3秒后返回构造函数新生成的对象 Person&#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h3><p>由于箭头函数不绑定<code>this</code>， 它会捕获其所在（即定义的位置）上下文的<code>this</code>值， 作为自己的<code>this</code>值，</p>
<p>因为箭头函数可以捕获其所在上下文的this值 所以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">        // 回调里面的 `this` 变量就指向了期望的那个对象 Person 了</span><br><span class="line">        this.age++;</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();</span><br></pre></td></tr></table></figure></p>
<p>下图可以看到，在setTimeout中的<code>this</code>指向了构造函数新生成的对象，而普通函数指向了全局<code>window</code>对象<br><img src="http://ww1.sinaimg.cn/large/a85d55ddly1fzdl7sy5hfj20dm06qmx4.jpg" alt=""></p>
<ol>
<li><p><code>call()</code> / <code>apply()</code> / <code>bind()</code> 方法对<strong>于箭头函数来说只是传入参数,对它的 <code>this</code> 毫无影响</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var adder = &#123;</span><br><span class="line">  base : 1,</span><br><span class="line">    </span><br><span class="line">  add : function(a) &#123;</span><br><span class="line">    var f = v =&gt; v + this.base;</span><br><span class="line">    return f(a);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  addThruCall: function inFun(a) &#123;</span><br><span class="line">    var f = v =&gt; v + this.base;</span><br><span class="line">    var b = &#123;</span><br><span class="line">      base : 2</span><br><span class="line">    &#125;;</span><br><span class="line">            </span><br><span class="line">    return f.call(b, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(adder.add(1));         // 输出 2</span><br><span class="line">console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3，其内部的this并没有因为call() 而改变，其this值仍然为函数inFun的this值，指向对象adder</span><br></pre></td></tr></table></figure>
</li>
<li><p>考虑到 this 是词法层面上的，严格模式中与 <code>this</code> 相关的规则都将被忽略。（可以<strong>忽略是否在严格模式下</strong>的影响）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var f = () =&gt; &#123;&apos;use strict&apos;; return this&#125;;</span><br><span class="line">var p = () =&gt; &#123; return this&#125;;</span><br><span class="line">console.log(1,f() === window);</span><br><span class="line">console.log(2,f() === p());</span><br><span class="line">//1 true</span><br><span class="line">//2 true</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="如果将箭头函数当做一个方法使用"><a href="#如果将箭头函数当做一个方法使用" class="headerlink" title="如果将箭头函数当做一个方法使用"></a>如果将箭头函数当做一个方法使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  i: 10,</span><br><span class="line">  b: () =&gt; console.log(this.i, this),</span><br><span class="line">  c: function() &#123;</span><br><span class="line">    console.log( this.i, this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b();  // undefined window&#123;...&#125;</span><br><span class="line">obj.c();  // 10 Object &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p><strong>作为方法的箭头函数this指向全局window对象，而普通函数则指向调用它的对象</strong></p>
<p>所以，对于测评的这道题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> window.name = &quot;bar&quot;;</span><br><span class="line">const object = &#123;</span><br><span class="line">  name: &quot;foo&quot;,</span><br><span class="line">  hi: function() &#123;</span><br><span class="line">    console.assert(this.name === &quot;foo&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  hello: () =&gt;  &#123;</span><br><span class="line">    console.assert(this.name === &quot;foo&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">object.hi(); //正常or报错？</span><br><span class="line">object.hello(); //正常or报错？</span><br></pre></td></tr></table></figure></p>
<p>对于<code>object.hi()</code>,<code>this</code>指向<code>object</code>,<code>this.name=&quot;foo&quot;</code>,而对于<code>object.hello()</code>,<code>this</code>指向全局对象，<code>this.name=&quot;bar&quot;</code></p>
<h1 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call(), apply(), bind()"></a>call(), apply(), bind()</h1><p>从上面<code>this</code>指向的部分例子中就可以看出，<code>apply</code> 、 <code>call</code> 、<code>bind</code> 三者都是用来改变函数的this对象的指向的。</p>
<h2 id="apply-amp-call"><a href="#apply-amp-call" class="headerlink" title="apply &amp; call"></a>apply &amp; call</h2><p>其中<code>call</code>和<code>apply</code>更相似，先看下它们俩的语法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg, arg1, arg2, ...)</span><br><span class="line">fun.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure></p>
<p>其中<code>thisArg</code>为函数<code>fun</code>运行时使用的<code>this</code>值，如果这个函数处于非严格模式下，则指定为 <code>null</code> 或 <code>undefined</code> 时会自动替换为指向全局对象，原始值会被包装。而<code>arg1, arg2, ...</code>和<code>[argsArray]</code>均为传递给函数<code>fun</code>的参数。<br>由语法规范可以看出，<code>call()</code>方法接受的是参数列表，而<code>apply()</code>方法接受的是一个参数数组。</p>
<p>出了<code>this指向</code>中一类的例子外，在一个子构造函数中，可以通过调用父构造函数的<code>call</code>或<code>apply</code>方法来实现继承<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Product(name, price) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Food(name, price) &#123;</span><br><span class="line">  Product.call(this, name, price);</span><br><span class="line">  this.category = &apos;food&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Toy(name, price) &#123;</span><br><span class="line">  Product.apply(this, [name, price]);</span><br><span class="line">  this.category = &apos;toy&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cheese = new Food(&apos;feta&apos;, 5);</span><br><span class="line">var fun = new Toy(&apos;robot&apos;, 40);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://ww1.sinaimg.cn/large/a85d55ddly1fzdltxlz62j20bv0a6aa7.jpg" alt=""></p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>而<code>bind()</code>的不同之处在于它会创建一个新函数。</p>
<p>bind()方法<strong>创建一个新的函数</strong>，在调用时设置this关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。</p>
<p>例如，在 <code>f()</code> 函数上调用<code>bind()</code> 方法并传入参数 <code>obj</code> ，即 <code>f.bind(obj)</code> ，这将返回一个新函数, 新函数会把原始的函数 <code>f()</code> 当做 <code>obj</code> 的方法来调用,就像 <code>obj.f()</code> 似的，当然这时 <code>f()</code> 函数中的 <code>this</code> 对象指向的是 obj 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(y,z)&#123;</span><br><span class="line">    return this.x+y+z;</span><br><span class="line">&#125;</span><br><span class="line">var m=f.bind(&#123;x:1&#125;,2); </span><br><span class="line">console.log(m(3));  // 6</span><br></pre></td></tr></table></figure>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure></p>
<p><code>thisArg</code>是调用绑定函数时作为this参数传递给目标函数的值。 如果使用<code>new</code>运算符构造绑定函数，则忽略该值。<code>bind</code>传递参数和<code>call</code>相同，接受的是参数列表。</p>
<ul>
<li>简单使用情形一<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o=&#123;</span><br><span class="line">    f: function () &#123;</span><br><span class="line">        var self=this;</span><br><span class="line">        var fff=function() &#123;</span><br><span class="line">            console.log(self.value);  //此时 this 指向的是全局作用域 global/window，因此需要使用 self 指向对象o</span><br><span class="line">        &#125;;</span><br><span class="line">        fff();</span><br><span class="line">    &#125;,</span><br><span class="line">    value: &quot;Hello World!&quot;</span><br><span class="line">&#125;;</span><br><span class="line">o.f(); // Hello World!</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上例把 <code>this</code> 赋值给了中间变量 <code>self</code>来保持 <code>this</code> 上下文，这样在内部嵌套的函数中能够使用 <code>self</code> 访问到对象<code>o</code>，否则仍使用 <code>this.value</code>，内部嵌套函数的<code>this</code>此时指向的是全局作用域，最后的输出将会是 <code>undefined</code>，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o=&#123;</span><br><span class="line">    f: function () &#123;</span><br><span class="line">        var self=this;</span><br><span class="line">        var fff=function() &#123;</span><br><span class="line">            console.log(this.value); </span><br><span class="line">        &#125;;</span><br><span class="line">        fff();</span><br><span class="line">    &#125;,</span><br><span class="line">    value: &quot;Hello World!&quot;</span><br><span class="line">&#125;;</span><br><span class="line">o.f(); // undefined</span><br></pre></td></tr></table></figure></p>
<p>但是，如果使用<code>bind()</code>函数，将<code>fff</code>函数的绑定在对象<code>o</code>中，即将<code>fff()</code>函数内部的 <code>this</code> 对象绑定为对象 <code>o</code>，那么此时 <code>this.value</code> 是存在的。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o=&#123;</span><br><span class="line">    f: function () &#123;</span><br><span class="line">        var self=this;</span><br><span class="line">        var fff=function() &#123;</span><br><span class="line">            console.log(this.value); // bind(this) 中 this 指向的是o，这里也可直接写成 bind(o)</span><br><span class="line">        &#125;.bind(this);</span><br><span class="line">        fff();</span><br><span class="line">    &#125;,</span><br><span class="line">    value: &quot;Hello World!&quot;</span><br><span class="line">&#125;;</span><br><span class="line">o.f(); // Hello World！</span><br></pre></td></tr></table></figure></p>
<p><code>bind</code>只能使用一次，多次使用无效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var bar = function()&#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line">var foo = &#123;</span><br><span class="line">    x:3</span><br><span class="line">&#125;</span><br><span class="line">var sed = &#123;</span><br><span class="line">    x:4</span><br><span class="line">&#125;</span><br><span class="line">var func = bar.bind(foo).bind(sed);</span><br><span class="line">func(); // 3</span><br><span class="line"> </span><br><span class="line">var fiv = &#123;</span><br><span class="line">    x:5</span><br><span class="line">&#125;</span><br><span class="line">var func = bar.bind(foo).bind(sed).bind(fiv);</span><br><span class="line">func(); // 3</span><br></pre></td></tr></table></figure></p>
<p>原因是，在<code>Javascript</code>中，多次 <code>bind()</code> 是无效的。更深层次的原因， <code>bind()</code> 的实现，相当于使用函数在内部包了一个 <code>call</code> /<code>apply</code> ，第二次 <code>bind()</code> 相当于再包住第一次<code>bind()</code> ,故第二次以后的 <code>bind</code> 是无法生效的。</p>
<h3 id="apply、call、bind比较"><a href="#apply、call、bind比较" class="headerlink" title="apply、call、bind比较"></a>apply、call、bind比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    x: 81,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">var foo = &#123;</span><br><span class="line">    getX: function() &#123;</span><br><span class="line">        return this.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">console.log(foo.getX.bind(obj)());  //81</span><br><span class="line">console.log(foo.getX.call(obj));    //81</span><br><span class="line">console.log(foo.getX.apply(obj));   //81</span><br></pre></td></tr></table></figure>
<p><code>apply</code> 、 <code>call</code> 、<code>bind</code> 三者都是用来改变函数的<code>this</code>对象的指向的；<br><code>apply</code> 、 <code>call</code> 、<code>bind</code> 三者第一个参数都是<code>this</code>要指向的对象，也就是想指定的上下文；<br><code>apply</code> 、 <code>call</code> 、<code>bind</code> 三者都可以利用后续参数传参；<br><code>bind</code> 是返回对应函数，便于稍后调用；<code>apply</code> 、<code>call</code> 则是立即调用 。<br><img src="http://ww1.sinaimg.cn/large/a85d55ddly1fzdmexhrrsj20og0aidgi.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/20/notes_of_this/" data-id="cjr5923u5000gx8owiqzw6151" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/01/19/summary_of_exam/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">测评总结与反思</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/20/notes_of_this/">this, call(), apply() 和bind()</a>
          </li>
        
          <li>
            <a href="/2019/01/19/summary_of_exam/">测评总结与反思</a>
          </li>
        
          <li>
            <a href="/2019/01/16/single_responsibility_principle/">单一职责原则</a>
          </li>
        
          <li>
            <a href="/2019/01/16/notes_of_java_foundation/">Java基础语法笔记</a>
          </li>
        
          <li>
            <a href="/2019/01/15/IntelliJ-IDEA-Tutorial/">初级IntelliJ IDEA使用总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Song Nan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>