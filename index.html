<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>宋博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="宋博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="宋博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="宋博客">
  
    <link rel="alternate" href="/atom.xml" title="宋博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">宋博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">我爱学习</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-summary_week5_2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/13/summary_week5_2/" class="article-date">
  <time datetime="2019-01-13T13:21:18.266Z" itemprop="datePublished">2019-01-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/13/summary_week5_2/">总结—第一阶段第四周</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>上周忘记写总结了…这两周就是在做<code>todo-list</code>和思沃影院。做这两个作业时，回顾、应用了很多以前学习的知识，对以前学习的内容有了更好的掌握。<code>HTML</code>和<code>CSS</code>是必不可少的，不用说。做<code>todo-list</code>是用了很多的事件监听和事件代理，以及<code>DOM</code>方法和属性，<code>localStorage</code>方法。完成<code>todo-list</code>后，做思沃影院更好做了。如显示推荐电影和分类电影就采用了<code>todod-list</code>里显示<code>todos</code>的方法，而随机推荐不重复的高分电影和轮播图则是想到了之前打地鼠作业里控制地鼠随机连续出动的方法完成的。可见，还是要多练，可能刚学的时候没有很深的感受，通过练习后就能理解的更好也掌握的更好。</p>
<h2 id="三圈"><a href="#三圈" class="headerlink" title="三圈"></a>三圈</h2><p>上周有元旦假期，这周相比上周当然是处于学习圈了。但是这周不是简单的代码练习，而是有两个小项目，其中一个还要合作完成，虽然比较忙，但是完成之后看着这两个小项目，还是很开心的，小有成就感233.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/13/summary_week5_2/" data-id="cjquy660e0009xkowml1wey4r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-summary_week3_2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/29/summary_week3_2/" class="article-date">
  <time datetime="2018-12-29T14:10:59.401Z" itemprop="datePublished">2018-12-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/29/summary_week3_2/">总结—JS进阶第三周</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习和反思"><a href="#学习和反思" class="headerlink" title="学习和反思"></a>学习和反思</h2><p>这周前半周主要在做ES6的运算合集和复习前面的知识。运算合集这是之前做过的，没有遇到什么问题。复习方面，周五的小问题环节，我发现我真是严格按照考察表复习的…有些东西考察表上虽然没写，但是是最基本的，还是要好好复习啊..譬如引入CSS的方法，我只是记住了有三种，以及它们大概的内容…在后面的复习中对于一些最基本的内容，比如定义什么的，还是要记清楚。<br>后两天就是在做打印成绩单任务卡，也是了解感受了测试驱动开发，任务卡还没完成，做得过程太粗心了，花了些多余的时间。对于打印提示的main()的测试代码，还没想好怎么写。</p>
<h2 id="三圈"><a href="#三圈" class="headerlink" title="三圈"></a>三圈</h2><p>时间过得好快，也感觉不出来是什么圈…相比上周的舒适圈的话，这周算处于学习圈吧，因为这周的打印成绩单还挺难的，上周的任务卡就比较简单了，自己一个人就做得来。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/29/summary_week3_2/" data-id="cjquy65zv0006xkow2kbt46tq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-summary_week2_2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/23/summary_week2_2/" class="article-date">
  <time datetime="2018-12-23T12:58:00.509Z" itemprop="datePublished">2018-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/23/summary_week2_2/">总结—JS进阶第二周</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>这周的新内容是ES6和面向对象。</p>
<p>ES6新特性中中目前在写代码中使用较多的是<code>let</code>,<code>const</code>，模板字符串和箭头函数，其他内容处于了解阶段。</p>
<p>面向对象任务卡了解了什么是面向对象，其最主要的特质是<strong>封装</strong>，<strong>继承</strong>，<strong>多态</strong>，以及面向对象编程的优点。加下线下学习的内容，了解了想要创建一个指定类型的对象时可以用创建函数法和对象原型，以及两者兼有的方法，ES6还提供了更简洁的方法，类<code>class</code>。</p>
<h2 id="三圈"><a href="#三圈" class="headerlink" title="三圈"></a>三圈</h2><p>这周相比于上周我处在<strong>舒适圈</strong>，主要原因是这周的任务少，比较轻松。不过这周别的事情也不少，去学校联系毕设呀，和快回家的同学吃饭聚会呀，年会呀，和考研的朋友谈心呀，果真是不管任务多少，都能拖拖拉拉做一个礼拜啊…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/23/summary_week2_2/" data-id="cjquy65zo0005xkownbywgvzs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-summary_week1_2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/15/summary_week1_2/" class="article-date">
  <time datetime="2018-12-15T12:09:03.157Z" itemprop="datePublished">2018-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/15/summary_week1_2/">总结—JavaScript进阶第一周</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>这周的新内容是了解了node.js和npm：</p>
<ul>
<li>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。</li>
<li>NPM（node package manager)，是基于couchdb的一个数据库，通常称为node包管理器，主要功能就是管理node包，包括：安装、卸载、更新、查看、搜索、发布等。NPM详细记录了每个包的信息（作者、版本、依赖、授权信息等）。</li>
</ul>
<p>其次这周主要是做了大量JS数组、字符串、对象方法的练习，经过大量的练习，我对JS数组等方法有了更深的理解，也不再像以前一样总是倾向于使用<code>for</code>循环等语句来编写代码。</p>
<p>这周还有一个任务就是复习Tasking,完成“黄焖鸡”，做好任务分解后，再来写代码确实要简单快捷许多。</p>
<h2 id="三圈"><a href="#三圈" class="headerlink" title="三圈"></a>三圈</h2><p>这周相比于上周，我觉得自己处于<strong>学习圈</strong>。这周学习的内容本身不难，主要是任务量比较大。运算合集的题还挺多的，我也做了挺长时间，但是不得不说全部做完了之后还是很开心的！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/15/summary_week1_2/" data-id="cjquy65zi0004xkowq8snb60y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-notes_of_advanced_js" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/09/notes_of_advanced_js/" class="article-date">
  <time datetime="2018-12-09T10:37:53.798Z" itemprop="datePublished">2018-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/09/notes_of_advanced_js/">JavaScript进阶笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><ul>
<li><code>Node.js</code>概述<ul>
<li><code>Node.js</code> 是一个基于 Chrome V8 引擎的 <code>JavaScript</code> 运行环境。</li>
<li><code>Node.js</code> 使用了一个事件驱动、非阻塞式 <code>I/O</code> 的模型，使其轻量又高效。</li>
<li><code>Node.js</code> 的包管理器 <code>npm</code>，是全球最大的开源库生态系统。</li>
</ul>
</li>
<li><code>Node.js</code>特点<ul>
<li>使用的是为Google Chrome提供动力的V8虚拟机。V8让node在性能上得到巨大的提升，因为它去掉了中间环节，执行的不是字节码，用的也不是解释器，而是直接编译成了本地机器码。</li>
<li><code>JavaScript</code>语言</li>
<li>事件驱动，非阻塞式<code>I/O</code></li>
<li>使用 <code>npm</code> 来管理包</li>
</ul>
</li>
<li>使用<code>node</code>运行<code>js</code>文件：<ul>
<li>交互模式（连按两次<code>Ctrl+C</code>退出交互模式）</li>
<li>命令行模式</li>
</ul>
</li>
</ul>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><ul>
<li>NPM是什么？<br>NPM（node package manager)，通常称为node包管理器，主要功能就是管理node包，包括：安装、卸载、更新、查看、搜索、发布等。NPM是基于couchdb一个数据库，详细记录了每个包的信息（作者、版本、依赖、授权信息等）。它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块）。来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。</li>
<li>NPM的作用<ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
</ul>
</li>
<li>NPM常用命令<ul>
<li><code>npm -v</code>：查看npm版本号</li>
<li><code>npm init</code>: 初始化项目</li>
<li><code>npm install module</code>:本地安装需要的模块module</li>
<li><code>npm install module -g</code>:全局安装需要的模块module</li>
<li>在<code>package.json</code>文件的<code>dependencies</code>块下或通过<code>npm ls</code>命令查看当前项目下依赖的包</li>
<li><code>npm uninstall module</code>：卸载模块</li>
<li><code>npm update module</code>：更新模块</li>
<li><code>npm search module</code>:搜索模块</li>
<li><code>npm help &lt;command&gt;</code>:查看某条命令的详细帮助</li>
</ul>
</li>
</ul>
<h2 id="ECMAScript-6"><a href="#ECMAScript-6" class="headerlink" title="ECMAScript 6"></a>ECMAScript 6</h2><ul>
<li>ECMAScript 6 简介：<ul>
<li>ECMAScript(ES6) 是JavaScript语言的下一代标准，已经在2015年6月正式发布了；在 JavaScript 的基础上做了重大的更新，提供了更优雅的语法和特性。</li>
</ul>
</li>
<li>ECMAScript 和 JavaScript 的关系<ul>
<li>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。名字不同的原因：<ol>
<li>商标，1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。根据授权协议，只有Netscape公司(Javascript 的创造者)可以合法地使用JavaScript这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标</li>
<li>想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</li>
</ol>
</li>
</ul>
</li>
<li>块级作用域</li>
</ul>
<h4 id="没有块级作用域，会带来很多不合理的场景。如："><a href="#没有块级作用域，会带来很多不合理的场景。如：" class="headerlink" title="没有块级作用域，会带来很多不合理的场景。如："></a>没有块级作用域，会带来很多不合理的场景。如：</h4><ul>
<li>第一种场景，内层变量可能会覆盖外层变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var tmp = new Date();</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(tmp);</span><br><span class="line">  if (false) &#123;</span><br><span class="line">    var tmp = &apos;hello world&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); // undefined</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>函数<code>f</code>执行后，输出结果为<code>undefined</code>，原因在于<code>if</code>内的<code>tmp</code>用<code>var</code>声明，在全局范围内有效，导致内层的tmp变量覆盖了外层的tmp变量，变量提升，输出语句写在<code>tmp</code>声明语句之前，输出<code>undefined</code>。</p>
<ul>
<li>第二种场景，用来计数的循环变量泄露为全局变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">  console.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i); // 5</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码中，变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
<p>为了避免这些不合理的场景，ES6通过<code>let</code>和<code>const</code>增加了块级作用域。<code>let</code> 和 <code>const</code> 只在于当前的块作用域中有效，而 <code>var</code> 声明的变量是在函数作用域内有效。<code>const</code> 和 <code>let</code> 的区别则在于， <code>const</code> 声明变量的同时必须立即给一个初始值，且无法在对该值进行修改。如果该初始值是一个对象，那么该对象的值是可以被修改的。</p>
<h4 id="有块级作用域后："><a href="#有块级作用域后：" class="headerlink" title="有块级作用域后："></a>有块级作用域后：</h4><ul>
<li><p>ES6 允许块级作用域的任意嵌套。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123;let insane = &apos;Hello World&apos;&#125;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>外层作用域无法读取内层作用域的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;let insane = &apos;Hello World&apos;&#125;</span><br><span class="line">  console.log(insane); // 报错</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内层作用域可以定义外层作用域的同名变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  let insane = &apos;Hello World&apos;;</span><br><span class="line">  &#123;let insane = &apos;Hello World&apos;&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">function func() &#123;</span><br><span class="line">  let a = 10;</span><br><span class="line">  var a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">function func() &#123;</span><br><span class="line">  let a = 10;</span><br><span class="line">  let a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在块级作用域内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  // TDZ开始</span><br><span class="line">  tmp = &apos;abc&apos;; // ReferenceError</span><br><span class="line">  console.log(tmp); // ReferenceError</span><br><span class="line"></span><br><span class="line">  let tmp; // TDZ结束</span><br><span class="line">  console.log(tmp); // undefined</span><br><span class="line"></span><br><span class="line">  tmp = 123;</span><br><span class="line">  console.log(tmp); // 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>块级作用域与函数声明</p>
</li>
</ul>
<p>ES6 规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。但是为了减轻对老代码的影响，，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p>
<ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<p>根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于<code>var</code>声明的变量。考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明语句</span><br><span class="line">&#123;</span><br><span class="line">  let a = &apos;secret&apos;;</span><br><span class="line">  function f() &#123;</span><br><span class="line">    return a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">&#123;</span><br><span class="line">  let a = &apos;secret&apos;;</span><br><span class="line">  let f = function () &#123;</span><br><span class="line">    return a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p>
<ul>
<li>变量的解构赋值</li>
</ul>
<p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<ul>
<li><p>数组的解构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let [foo, [[bar], baz]] = [1, [[2], 3]];</span><br><span class="line">foo // 1</span><br><span class="line">bar // 2</span><br><span class="line">baz // 3</span><br><span class="line"></span><br><span class="line">let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];</span><br><span class="line">third // &quot;baz&quot;</span><br><span class="line"></span><br><span class="line">let [x, , y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 3</span><br><span class="line"></span><br><span class="line">let [head, ...tail] = [1, 2, 3, 4];</span><br><span class="line">head // 1</span><br><span class="line">tail // [2, 3, 4]</span><br><span class="line"></span><br><span class="line">let [x, y, ...z] = [&apos;a&apos;];</span><br><span class="line">x // &quot;a&quot;</span><br><span class="line">y // undefined</span><br><span class="line">z // []</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果解构不成功，变量的值就等于undefined。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let [foo] = [];</span><br><span class="line">let [bar, foo] = [1];</span><br></pre></td></tr></table></figure>
</li>
<li><p>不完全解构：等号左边的模式，只匹配一部分的等号右边的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let [x, y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 2</span><br><span class="line"></span><br><span class="line">let [a, [b], d] = [1, [2, 3], 4];</span><br><span class="line">a // 1</span><br><span class="line">b // 2</span><br><span class="line">d // 4</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">let [foo] = 1;</span><br><span class="line">let [foo] = false;</span><br><span class="line">let [foo] = NaN;</span><br><span class="line">let [foo] = undefined;</span><br><span class="line">let [foo] = null;</span><br><span class="line">let [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>对象的解构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">foo // &quot;aaa&quot;</span><br><span class="line">bar // &quot;bbb&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let &#123; bar, foo &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">foo // &quot;aaa&quot;</span><br><span class="line">bar // &quot;bbb&quot;</span><br><span class="line"></span><br><span class="line">let &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">baz // undefined</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123; foo: baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">baz // &quot;aaa&quot;</span><br><span class="line">foo // error: foo is not defined</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>字符串的解构赋值<br>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const [a, b, c, d, e] = &apos;hello&apos;;</span><br><span class="line">a // &quot;h&quot;</span><br><span class="line">b // &quot;e&quot;</span><br><span class="line">c // &quot;l&quot;</span><br><span class="line">d // &quot;l&quot;</span><br><span class="line">e // &quot;o&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>字符串拓展</p>
<ul>
<li>模版字符串</li>
</ul>
<p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串（所有的空格和缩进都会被保留在输出之中），或者在字符串中嵌入变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 普通字符串</span><br><span class="line">`In JavaScript &apos;\n&apos; is a line-feed.`</span><br><span class="line"></span><br><span class="line">// 多行字符串</span><br><span class="line">`In JavaScript this is</span><br><span class="line">not legal.`</span><br><span class="line"></span><br><span class="line">console.log(`string text line 1</span><br><span class="line">string text line 2`);</span><br><span class="line"></span><br><span class="line">// 字符串中嵌入变量</span><br><span class="line">let name = &quot;Bob&quot;, time = &quot;today&quot;;</span><br><span class="line">`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`</span><br></pre></td></tr></table></figure>
<p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let greeting = `\`Yo\` World!`;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数的扩展</p>
<ul>
<li><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function log(x, y = &apos;World&apos;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(&apos;Hello&apos;) // Hello World</span><br><span class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</span><br><span class="line">log(&apos;Hello&apos;, &apos;&apos;) // Hello</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6 引入 <code>rest</code> 参数（形式为…变量名），用于获取函数的多余参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function example(...values)&#123;</span><br><span class="line">    console.log(values)// console: [1,2,3,4]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example(1,2,3,4) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var a = [1,2,3]</span><br><span class="line"></span><br><span class="line">var b = [...a,4,5,6] //b = [1,2,3,4,5,6]</span><br></pre></td></tr></table></figure>
</li>
<li><p>箭头函数</p>
<ul>
<li><p>ES6 允许使用“箭头”（=&gt;）定义函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var f = v =&gt; v;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">var f = function (v) &#123;</span><br><span class="line">  return v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f = () =&gt; 5;</span><br><span class="line">// 等同于</span><br><span class="line">var f = function () &#123; return 5 &#125;;</span><br><span class="line"></span><br><span class="line">var sum = (num1, num2) =&gt; num1 + num2;</span><br><span class="line">// 等同于</span><br><span class="line">var sum = function(num1, num2) &#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果箭头函数的函数体只包含一行代码，则可以不需要写大括号以及 return 语句返回（如果有返回值）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var sum = (num1,num2) =&gt; num1+num2</span><br><span class="line">等同于</span><br><span class="line">var sum = (num1,num2) =&gt; &#123;return num1+num2&#125;</span><br><span class="line">等同于</span><br><span class="line">var sum = function(num1,num2)&#123;return num1+num2&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li>面向对象编程：<br>把一组数据结构和处理它们的方法组成<strong>对象</strong>(Object), 把相同行为的对象归纳为<strong>类</strong>(Class), 通过类的<strong>封装</strong>(encapsulation)隐藏内部细节，通过<strong>继承</strong>(inheritance)实现类的<strong>特化</strong>(specializetion)/<strong>泛化</strong>(generalization), 通过<strong>多态</strong>(polymorphism)实现基于对象类型的<strong>动态分派</strong>。其实就是我们按照正常的思维去写程序，我们会将现实世界中的东西视为一个个对象，然后他们的行为就是一个个方法。<br><img src="https://pic1.zhimg.com/80/664ba37eeee9f4623c06c066867f1d38_hd.jpg" alt=""></li>
<li>面向对象这个<strong>对象</strong>，指的是客体。所谓客体是指客观存在的对象实体和主观抽象的概念。 </li>
<li>面向对象的好处？<ol>
<li>接近人的思维，符合人类对现实世界的认知；</li>
<li>封装特性可以使开发者不必在意内部的具体实现，更方便互相协作；</li>
<li>继承特性可以减少代码冗余，实现代码复用；</li>
<li>多态特性令子类相比父类有不同的行为，这是非常接近现实的。</li>
</ol>
</li>
<li>面向对象是为了解决系统的<strong>可维护性</strong>，<strong>可扩展性</strong>，<strong>可重用性</strong>。<ul>
<li>面向对象的三大特征： <ul>
<li>封装：找到变化并且把它封装起来。封装的作用，就解决了程序的可扩展性。 </li>
<li>继承：子类继承父类，可以继承父类的方法及属性，实现了多态以及代码的重用，因此也解决了系统的重用性和扩展性，但是继承破坏了封装，因为他是对子类开放的，修改父类会导致所有子类的改变，因此继承一定程度上又破坏了系统的可扩展性，所以继承需要慎用。</li>
<li>多态：接口的多种不同的实现方式即为多态。</li>
</ul>
</li>
</ul>
</li>
<li>面对对象编程三大步骤：<ul>
<li>面向对象的分析(OOA)：分析需求，先不要思考怎么用程序实现它，先分析需求中稳定不变的客体都是些什么，这些客体之间的关系是什么。</li>
<li>面向对象的设计(OOD)：把第一步分析出来的需求，通过进一步扩充模型，变成可实现的、符合成本的、模块化的、低耦合高内聚的模型。</li>
<li>面向对象的编程实现(OOP)：使用面向对象的实现模型 。</li>
</ul>
</li>
<li>面向对象和基于对象的区别<br>“面向对象”和“基于对象”都实现了“封装”的概念，但是面向对象实现了“继承和多态”，而“基于对象”没有实现这些</li>
</ul>
<h3 id="1-生成实例对象的原始模式-字面量"><a href="#1-生成实例对象的原始模式-字面量" class="headerlink" title="1.生成实例对象的原始模式,字面量"></a>1.生成实例对象的原始模式,字面量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　var Cat = &#123;</span><br><span class="line">　　　　name : &apos;&apos;,</span><br><span class="line"></span><br><span class="line">　　　　color : &apos;&apos;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>根据这个原型对象的规格（schema），生成两个实例对象:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　var cat1 = &#123;&#125;; // 创建一个空对象</span><br><span class="line"></span><br><span class="line">　　　　cat1.name = &quot;大毛&quot;; // 按照原型对象的属性赋值</span><br><span class="line"></span><br><span class="line">　　　　cat1.color = &quot;黄色&quot;;</span><br><span class="line"></span><br><span class="line">　　var cat2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">　　　　cat2.name = &quot;二毛&quot;;</span><br><span class="line"></span><br><span class="line">　　　　cat2.color = &quot;黑色&quot;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这样的写法有两个缺点<ul>
<li>一是如果多生成几个实例，写起来就非常麻烦；</li>
<li>二是实例与原型之间，没有任何办法，可以看出有什么联系。</li>
</ul>
</li>
</ul>
<h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name,color) &#123;</span><br><span class="line"></span><br><span class="line">　　　　return &#123;</span><br><span class="line"></span><br><span class="line">　　　　　　name:name,</span><br><span class="line"></span><br><span class="line">　　　　　　color:color</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>然后生成实例对象，就等于是在调用函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　var cat1 = Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class="line"></span><br><span class="line">　　var cat2 = Cat(&quot;二毛&quot;,&quot;黑色&quot;);</span><br></pre></td></tr></table></figure></p>
<p>这种方法的问题依然是，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。</p>
<h3 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3.构造函数"></a>3.构造函数</h3><p>“构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　function Cat(name,color)&#123;</span><br><span class="line"></span><br><span class="line">　　　　this.name=name;</span><br><span class="line"></span><br><span class="line">　　　　this.color=color;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成实例对象了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class="line"></span><br><span class="line">　　var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);</span><br><span class="line"></span><br><span class="line">　　alert(cat1.name); // 大毛</span><br><span class="line"></span><br><span class="line">　　alert(cat1.color); // 黄色</span><br></pre></td></tr></table></figure></p>
<p><code>instanceof</code>运算符，验证原型对象与实例对象之间的关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　alert(cat1 instanceof Cat); //true</span><br><span class="line"></span><br><span class="line">　　alert(cat2 instanceof Cat); //true</span><br></pre></td></tr></table></figure></p>
<p>构造函数方法存在浪费内存的问题,生成示例时，对象内的方法和属性都是指向不同的内存地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(cat1.eat == cat2.eat); //false</span><br></pre></td></tr></table></figure></p>
<h3 id="4-prototype模式"><a href="#4-prototype模式" class="headerlink" title="4.prototype模式"></a>4.prototype模式</h3><p>Javascript规定，每一个构造函数都有一个<code>prototype</code>属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这意味着，我们可以把那些不变的属性和方法，直接定义在<code>prototype</code>对象上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　function Cat(name,color)&#123;</span><br><span class="line"></span><br><span class="line">　　　　this.name = name;</span><br><span class="line"></span><br><span class="line">　　　　this.color = color;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　Cat.prototype.type = &quot;猫科动物&quot;;</span><br><span class="line"></span><br><span class="line">　　Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;)&#125;;</span><br></pre></td></tr></table></figure></p>
<p>生成实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class="line"></span><br><span class="line">　　var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);</span><br><span class="line"></span><br><span class="line">　　alert(cat1.type); // 猫科动物</span><br><span class="line"></span><br><span class="line">　　cat1.eat(); // 吃老鼠</span><br><span class="line"></span><br><span class="line">　　alert(cat1.eat == cat2.eat); //true</span><br></pre></td></tr></table></figure></p>
<p>prototype模式的缺点在于给实例添加或删除属性和方法时，原型的属性和方法也会添加或删除。所以，可以结合构造函数和prototype模式。</p>
<h3 id="5-class"><a href="#5-class" class="headerlink" title="5.class"></a>5.class</h3><p>ES6 引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类的数据类型就是函数，类本身就指向构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof Point // &quot;function&quot;</span><br><span class="line">Point === Point.prototype.constructor // true</span><br></pre></td></tr></table></figure></p>
<p>使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Bar &#123;</span><br><span class="line">  doStuff() &#123;</span><br><span class="line">    console.log(&apos;stuff&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = new Bar();</span><br><span class="line">b.doStuff() // &quot;stuff&quot;</span><br></pre></td></tr></table></figure></p>
<p>类的所有方法都定义在类的<code>prototype</code>属性上面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toValue() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  constructor() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>Object.assign</code>方法可以很方便地一次向类添加多个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.assign(Point.prototype, &#123;</span><br><span class="line">  toString()&#123;&#125;,</span><br><span class="line">  toValue()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    super(x, y); // 调用父类的constructor(x, y)</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.color + &apos; &apos; + super.toString(); // 调用父类的toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。</p>
<p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/09/notes_of_advanced_js/" data-id="cjquy662z000exkow7eg7luwi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-summary_week4_1" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/08/summary_week4_1/" class="article-date">
  <time datetime="2018-12-08T12:22:29.145Z" itemprop="datePublished">2018-12-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/08/summary_week4_1/">总结—第一阶段第四周</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这周重点学习了DOM、事件、对象和AJAX，做了NASA主页，打地鼠，简单音乐播放器等的练习。</p>
<p>如果说上周处于学习圈的话，那我这周就是处于舒适圈。首先，对于上周，一个是有学校的一篇论文要完成，花费了一天，再是JS1的很多任务卡我开始都是用的<code>for</code>和<code>if</code>等语句写的，后来又再用JS的方法重做了一遍，也花费了很多时间和精力。而这周，因为之前的进度还可以，所以这周的任务卡不多，而且这周学校没有事情，时间比较充沛。这周学了DOM后，对事件又有了更好的理解，加上后面几个任务卡的完成的成就感，都会给了我心理上轻松的感觉吧。</p>
<p>这周的学习中我还是有许多不足，比较突出的是两点：</p>
<ul>
<li>太纠结于不重要的细节。比如做NASA主页时的颜色和尺寸的选择，花费了许多时间。后面的学习中，我应该抓住每个任务卡考核的重点，首先把重点都完成了，有余力时可以再调整一些细节。</li>
<li>写代码时抽成方法的意识和能力还不好。这一点我觉得卫林霄做得挺好的，我要向她学习，合理抽成方法，减少注释，提高自己代码的可读性。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/08/summary_week4_1/" data-id="cjquy66000007xkow7hzccjnq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-summary_week3_1" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/02/summary_week3_1/" class="article-date">
  <time datetime="2018-12-02T14:13:20.082Z" itemprop="datePublished">2018-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/02/summary_week3_1/">总结—第一阶段第三周</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这周的学习内容主要为JavaScript基础，学习的重点为JS的字符串、数组、对象及其相应的方法，和函数。我的学习进度稍快于任务营的安排，这点挺好。这周学习的主要不足在于，对于数组、字符串、函数等等这些过去在C语言和MATLAB中学习过的内容，再再JS中学习时，我总是习惯于使用过去的方法，于是有几个任务卡都是做了两遍。<strong>还是要多用多记多熟悉。</strong></p>
<p>后面学习的内容应该会学来越难，要继续保持现在的学习劲头啊！susuna!</p>
<p>周五线下学习我做了笔记分享，然鹅毫无互动T_T，下次再分享还是做个ppt吧，把笔记的重点部分提炼出来，这样应该会好做些。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/02/summary_week3_1/" data-id="cjquy661f000dxkowzcexx926" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-notes_of_js_2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/01/notes_of_js_2/" class="article-date">
  <time datetime="2018-12-01T14:41:35.889Z" itemprop="datePublished">2018-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/01/notes_of_js_2/">JS基础2笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="条件分支语句"><a href="#条件分支语句" class="headerlink" title="条件分支语句"></a>条件分支语句</h2><p>条件分支语句就是基于不同的<strong>条件</strong>去执行不同的<strong>动作</strong>。</p>
<p><strong>条件分支语句每次只执行多种情况中的一种情况。</strong></p>
<ul>
<li><p><code>if</code>语句</p>
<ul>
<li>语法格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (condition)&#123;</span><br><span class="line">// 当 condition==true 时执行的语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>if-else</code>语句</p>
<ul>
<li><p>语法格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (condition)&#123;</span><br><span class="line">// 当 condition==true 时执行的语句块1</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 当 condition==false 时执行的语句块2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当条件成立时，执行语句块1；当条件不成立时，执行语句块2.</p>
</li>
</ul>
</li>
<li><p>设置多个条件：把<code>if-else</code>语句组合起来。<code>else-if</code>语句:</p>
<ul>
<li>语法格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (condition1)&#123;</span><br><span class="line">// 当 condition1==true 时执行的语句块1</span><br><span class="line">&#125; else if (condition2)&#123;</span><br><span class="line">// 当 condition2==true 时执行的语句块2</span><br><span class="line">&#125; else &#123;</span><br><span class="line">// 当 condition1==false &amp;&amp; condition2==false 时执行的语句块3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>switch</code>语句</p>
<ul>
<li><p>语法格式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch(n)&#123; </span><br><span class="line">  case n1: </span><br><span class="line">    执行代码块 1</span><br><span class="line">    break; </span><br><span class="line">  case n2: </span><br><span class="line">    执行代码块 2 </span><br><span class="line">    break; </span><br><span class="line">  default: </span><br><span class="line">    与 case n1 和 case n2 不同时执行的代码块3 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里的<code>n</code>是一个变量，若<code>n</code>与<code>n1</code>相等，则执行代码块1，若<code>n</code>与<code>n2</code>相等，则执行代码块2，若都不相等，则执行代码块3。</li>
<li><code>break</code>语句在这里的作用是跳出这个<code>switch</code>语句块。如果不使用<code>break</code>,成立的<code>case</code>后的代码都会接着执行，用了<code>break</code>,就可以跳出这个<code>switch</code>语句块。<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2>循环结构的三个要素：<strong>循环变量</strong>、<strong>循环体</strong>和<strong>循环终止条件</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p><code>for</code>语句</p>
<ul>
<li><p>基本语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (循环变量初始化;循环终止条件;增量)&#123;</span><br><span class="line">循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从循环变量初始化值开始判断循环条件，若循环终止条件为<code>false</code>,跳出循环；若循环终止条件为<code>true</code>,则执行循环体内代码，然后对循环变量执行增量代码，再判断循环条件。以此循环，直到循环终止条件为<code>false</code>,跳出此循环。</p>
</li>
<li><p>举例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(var i = 1; i&lt;=10; i++)&#123;</span><br><span class="line">    console.log(&apos;学员&apos; + i + &apos;号。&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>while</code>语句</p>
<ul>
<li><code>while</code>语句属于前测试循环语句，也就是说，在循环体内的代码被执行之前，就会判断循坏终止条件，为<code>true</code>,则执行循环体代码，若为<code>false</code>则跳出循环。因此，循环体内的代码有可能永远不会被执行。</li>
<li><p>语句语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(循环终止条件)&#123;</span><br><span class="line">循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>举例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var i = 1; </span><br><span class="line">while(i&lt;=10)&#123;</span><br><span class="line">console.log(&apos;学员&apos; + i + &apos;号。&apos;);</span><br><span class="line">i = i + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>do-while</code>语句</p>
<ul>
<li><code>do-while</code>循环语句是一种后测试循环语句，即只有在循环体中的代码执行之后，才会判断循环终止条件。换句话说，在对条件表达式求值之前，循环体内的代码至少被执行一次。</li>
<li><p>语句语法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">循环体</span><br><span class="line">&#125;while(循环终止条件)</span><br></pre></td></tr></table></figure>
</li>
<li><p>举例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var i = 1;</span><br><span class="line">do&#123;</span><br><span class="line">console.log(&apos;学员&apos; + i + &apos;号。&apos;);</span><br><span class="line">i = i + 1;</span><br><span class="line">&#125; while(i&lt;=10)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>for循环更适合于循环次数已知的循环；</li>
<li>while循环更适合于循环次数未知的循环；</li>
<li>do-while循环至少执行一次。<h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2></li>
</ul>
</li>
<li>函数的基本语法如下<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function functionName(arg0, arg1, arg2 ... argn)&#123;</span><br><span class="line">    statements;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="事件和回调"><a href="#事件和回调" class="headerlink" title="事件和回调"></a>事件和回调</h2><ul>
<li>JavaScript语言将任务的执行模式可以分成两种：<strong>同步</strong>（Synchronous）和<strong>异步</strong>（Asychronous）。<ul>
<li>同步模式：一个任务完成之后，后边跟着一个任务接着执行；程序的执行顺序和排列顺序是一致的。</li>
<li>异步模式：则完全不同，每一个任务都有一个或者多个回调函数（callback），前一个任务结束的时候，不是执行下一个任务，而是执行回调函数，后一个任务则是不等前一个任务结束就执行。基本的异步模式有：<ul>
<li><a href="https://www.cnblogs.com/moltboy/archive/2013/04/24/3040213.html" target="_blank" rel="noopener">回调函数</a>（callback）：当函数的实现过程非常漫长时，使用回调函数进行异步处理，代码无需等待，可以继续其他任务。</li>
<li>事件是与浏览器或文档交互的瞬间，如点击按钮，填写表格等，它是JS与HTML之间交互的桥梁。<br><a href="https://segmentfault.com/a/1190000006934031" target="_blank" rel="noopener">事件监听</a>（Event） ,<a href="https://www.cnblogs.com/liugang-vip/p/5616484.html" target="_blank" rel="noopener">事件委托</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><ul>
<li><a href="http://www.w3school.com.cn/htmldom/index.asp" target="_blank" rel="noopener">DOM教程</a></li>
<li><code>DOM</code>（文档对象模型）是针对 <code>HTML</code> 和 <code>XML</code> 文档的一个 <code>API</code>(应用程序接口)，通过 DOM 可以去改变文档。</li>
<li>当浏览器载入HTML时，会生成相应的 DOM 树:<br><img src="https://blobscdn.gitbook.com/v0/b/gitbook-28427.appspot.com/o/assets%2F-LEnFv3jMWsHS31RfsLD%2F-LEnFymU6ro7LIcUvFQV%2F-LEnG-4J9dKFWiSXiSED%2Fhtml-dom.png?generation=1528794719454822&amp;alt=media" alt=""></li>
<li><p>即:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;我是title&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;a href=&quot;#&quot;&gt;我是文本链接&lt;/a&gt;</span><br><span class="line">    &lt;p id=&quot;myId&quot;&gt;我是p标签&lt;/p&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>DOM</code>常用属性：</p>
<ul>
<li><code>innerHTML</code>- 节点（元素）的文本值</li>
<li><code>parentNode</code> - 节点（元素）的父节点</li>
<li><code>childNodes</code> - 节点（元素）的子节点</li>
<li><code>attributes</code> - 节点（元素）的属性节点</li>
</ul>
</li>
<li><code>DOM</code>常用方法：</li>
</ul>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>getElementById()</code></td>
<td>返回带有指定 <code>ID</code> 的元素。</td>
</tr>
<tr>
<td><code>getElementsByTagName()</code></td>
<td>返回包含带有指定标签名称的所有元素的节点列表（集合/节点数组,<strong>下标号从0 开始</strong>）。</td>
</tr>
<tr>
<td><code>getElementsByClassName()</code></td>
<td>返回包含带有指定类名的所有元素的节点列表。</td>
</tr>
<tr>
<td><code>appendChild()</code></td>
<td>把新的子节点添加到指定节点。</td>
</tr>
<tr>
<td><code>removeChild()</code></td>
<td>删除子节点。</td>
</tr>
<tr>
<td><code>replaceChild()</code></td>
<td>替换子节点。</td>
</tr>
<tr>
<td><code>insertBefore()</code></td>
<td>在指定的子节点前面插入新的子节点。</td>
</tr>
<tr>
<td><code>createAttribute()</code></td>
<td>创建属性节点。</td>
</tr>
<tr>
<td><code>createElement()</code></td>
<td>创建元素节点。</td>
</tr>
<tr>
<td><code>createTextNode()</code></td>
<td>创建文本节点。</td>
</tr>
<tr>
<td><code>getAttribute()</code></td>
<td>返回指定的属性值。</td>
</tr>
<tr>
<td><code>setAttribute()</code></td>
<td>把指定属性设置或修改为指定的值。</td>
</tr>
</tbody>
</table>
<ul>
<li><p><code>Document</code> 类型</p>
<ul>
<li>对于一个 <code>HTML</code> 来说，文档节点 <code>Document</code> （是看不到的）就是它的根节点，这个根节点对应的对象就是 <code>document</code> ，我们可以通过根节点来访问它的子节点(Element 、Text)</li>
<li><p><code>document</code> 对象的常用属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.documentElement  // 可以直接拿到 html 节点的引用</span><br><span class="line">document.title //  可以直接获取 title 节点的文本 “我是title”</span><br><span class="line">document.URL // 获取 URL</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>document</code> 对象的常用方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById // docment.getElementById(&apos;myId&apos;) 可以获取到属性 id 为 ‘myId’ 的节点，在上面的代码中获取的也就是 p 节点</span><br><span class="line">document.getElementsByTagName //docment.getElementByTagName(&apos;p&apos;) 可以获取到节点为 p 的所有节点集</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>Element</code> 类型</p>
<ul>
<li>通常我们在使用 <code>document</code> 对象来获取节点时，返回的节点类型就是 <code>Element</code> 类型，所以我们想要对获取的节点进行操作，我们只需要使用 <code>Element</code> 包含的属性和方法即可。</li>
<li><p>常见属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myNode = document.getElementById(&apos;myId&apos;);</span><br><span class="line">myNode.id // 获取该节点的 id ，即 ‘myId‘</span><br><span class="line">myNode.tagName // 获取该节点的节点名，即 &apos;P&apos;，大部分浏览器返回的标签名都是大写</span><br><span class="line">myNode.className //获取该节点的 class</span><br></pre></td></tr></table></figure>
</li>
<li><p>常用方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//假如我们有一个 input，我们想要获取 input 的 type 属性，并对 type 属性进行操作</span><br><span class="line">&lt;input type=&apos;text&apos; id=&apos;input&apos;/&gt;</span><br><span class="line">​</span><br><span class="line">var myNode = document.getElementById(&apos;input&apos;)</span><br><span class="line">myNode.getAttribute(&apos;type&apos;) // 获取属性值，即 ‘text’</span><br><span class="line">myNode.setAttribute(&apos;type&apos;,&apos;password&apos;) // 将 type 属性值改为 password 类型</span><br><span class="line">myNode.removeAttribute(&apos;type&apos;) // 移除 type 属性</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul>
<li>JavaScript对象就是一组<strong>属性</strong>和<strong>方法（函数）</strong>的集合。</li>
<li><p>创建对象</p>
<ul>
<li><p>字面量表示法：<br>  一个对象也需要用一个变量来存储，然后通过点(.)来访问该对象的属性和方法。</p>
<ul>
<li><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var objectName = &#123;</span><br><span class="line">member1Name : member1Value,</span><br><span class="line">member2Name : member2Value,</span><br><span class="line">member3Name : member3Value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象成员的值可以是任意的。比如现在创建一个<code>person</code>对象:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">name : [&apos;Bob&apos;, &apos;Smith&apos;],</span><br><span class="line">age : 32,</span><br><span class="line">gender : &apos;male&apos;,</span><br><span class="line">interests : [&apos;music&apos;, &apos;skiing&apos;],</span><br><span class="line">bio : function() &#123;</span><br><span class="line">    alert(this.name[0] + &apos; &apos; + this.name[1] + &apos; is &apos; + this.age + &apos; years old. He likes &apos; + this.interests[0] + &apos; and &apos; + this.interests[1] + &apos;.&apos;);</span><br><span class="line">&#125;,</span><br><span class="line">greeting: function() &#123;</span><br><span class="line">    alert(&apos;Hi! I\&apos;m &apos; + this.name[0] + &apos;.&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>person</code>对象里有字符串(string)，数字(number)，两个数组(array)，两个函数(function)。前4个成员是资料项目，被称为<strong>对象的属性</strong>(property)，后两个成员是函数，允许对象对资料做一些操作，被称为<strong>对象的方法</strong>(method)。</p>
<p>这样一个<code>person</code>对象被称之为<code>对象的字面量</code>(literal)——手动的写出对象的内容来创建一个对象。</p>
</li>
</ul>
</li>
<li><p>使用<code>new</code>关键字</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o = new Object(); // 创建一个空对象，效果等同&#123;&#125;.</span><br><span class="line"></span><br><span class="line">var d = new Date(); // 创建一个表示当前时间的对象</span><br><span class="line"></span><br><span class="line">var r = new RegExp(&quot;js&quot;); // 创建一个正则表达式对象</span><br><span class="line"></span><br><span class="line">varperson = new Object();</span><br><span class="line"></span><br><span class="line">person.name = &quot;狼狼的蓝胖子&quot;;</span><br><span class="line"></span><br><span class="line">person.age = 25;</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Person(name, age) &#123;</span><br><span class="line"></span><br><span class="line">    this.name = name;</span><br><span class="line"></span><br><span class="line">    this.age = age;</span><br><span class="line"></span><br><span class="line">this.show=function()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = new Person(&quot;Jack&quot;,15);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>访问对象成员（属性或方法）</p>
<ul>
<li><p>点表示法<br>可以用点表示法(dot notation)来访问对象的属性和方法。</p>
<p>对象的<strong>名字</strong>表现为一个命名空间(namespace)，它必须<strong>写在第一位</strong>——当你想访问对象内部的属性或方法时，然后是一个点(<strong>.</strong>)，紧接着是你<strong>想要访问的项目</strong>，标识可以是简单属性的名字(name)，或者是数组属性的一个子元素，又或者是对象的方法调用。如下所示访问<code>person</code>对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person.name[0] // &apos;Bob&apos;</span><br><span class="line">person.age // 32</span><br><span class="line">person.interests[1] // &apos;skiing&apos;</span><br><span class="line">person.bio() // Bob Smith is 32 years old. He likes music and skiing.</span><br><span class="line">person.greeting() // Hi! I&apos;m Bob.</span><br></pre></td></tr></table></figure>
</li>
<li><p>子命名空间<br>可以用一个对象来做另一个对象成员的值，如将name:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name : &#123;</span><br><span class="line">first : &apos;Bob&apos;,</span><br><span class="line">last : &apos;Smith&apos;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>这就是创建了一个子命名空间。再要访问到Bobs属性时，只需要链式的再使用一次点表示法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person.name.first // &apos;Bob&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>括号表示法<br>还可以使用括号法访问对象属性。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person[&apos;age&apos;] // 32</span><br><span class="line">person[&apos;name&apos;][&apos;first&apos;] // &apos;Bob&apos;</span><br></pre></td></tr></table></figure>
<p>看起来很像访问一个数组元素。对象做了字符串到值的映射，而数组做的是数字到值的映射。所以对象有时被称之为关联数组。</p>
</li>
</ul>
</li>
<li><p>设置对象成员</p>
<ul>
<li><p>更改已存在的属性（或方法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person.age = 45</span><br><span class="line">person[&apos;name&apos;][&apos;last&apos;] = &apos;Cratchit&apos;</span><br><span class="line">person.age // 45</span><br><span class="line">person[&apos;name&apos;][&apos;last&apos;] // &apos;Cratchit&apos;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建新的属性（或方法（</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person[&apos;eyes&apos;] = &apos;hazel&apos;</span><br><span class="line">person.farewell = function() &#123; alert(&quot;Bye everybody!&quot;) &#125;</span><br><span class="line">person[&apos;eyes&apos;] // &apos;hazel&apos;</span><br><span class="line">person.farewell() // Bye everybody!</span><br></pre></td></tr></table></figure>
<p>括号表示法一个有用的地方是它不仅可以动态的去设置对象成员的值，还可以动态的去设置成员的名字。</p>
</li>
<li><p>删除属性（或方法）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete person.eyes;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断有无属性<code>in</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;name&apos; in person; // true</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>this</code><br>在<code>person</code>对象的<code>greeting</code>方法中使用了<code>this</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">greeting: function() &#123;</span><br><span class="line">    alert(&apos;Hi! I\&apos;m &apos; + this.name[0] + &apos;.&apos;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>关键字<code>this</code>指向了当前代码运行时的对象( 原文：the current object the code is being written inside )——这里即指<code>person</code>对象，<strong>保证了当代码的上下文(context)改变时变量的值的正确性</strong>（比如：不同的<code>person</code>对象拥有不同的<code>name</code>这个属性，很明显<code>greeting</code>这个方法需要使用的是它们自己的<code>name</code>）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var person1 = &#123;</span><br><span class="line">  name : &apos;Chris&apos;,</span><br><span class="line">  greeting: function() &#123;</span><br><span class="line">    alert(&apos;Hi! I\&apos;m &apos; + this.name + &apos;.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person2 = &#123;</span><br><span class="line">  name : &apos;Brian&apos;,</span><br><span class="line">  greeting: function() &#123;</span><br><span class="line">    alert(&apos;Hi! I\&apos;m &apos; + this.name + &apos;.&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">person1.greeting() // Hi! I&apos;m Chris.</span><br><span class="line">person2.greeting() // Hi! I&apos;m Brain.</span><br></pre></td></tr></table></figure></p>
<p>JavaScript对象基础​（<a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Basics" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Objects/Basics</a>）<br>​JavaScript对象基础讲解​（<a href="http://www.codexiu.cn/javascript/blog/40328/" target="_blank" rel="noopener">http://www.codexiu.cn/javascript/blog/40328/</a>）<br>JavaScript 对象基础​（<a href="http://wanwu.tech/2017/06/03/object-basics/" target="_blank" rel="noopener">http://wanwu.tech/2017/06/03/object-basics/</a>）</p>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><ul>
<li>JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。</li>
<li>JSON是一种嵌套层级结构，具有自我描述性，可以通过JavaScript进行解析，也通常会通过Ajax进行传输。</li>
<li>JSON建构于两种结构：<ul>
<li>“名称/值”对的集合（对象<code>{string:value, string:value}</code>）</li>
<li>值的有序列表（数组<code>[value, value]</code>）<ul>
<li>JSON对象和数组的属性名称<strong>必须</strong>是双引号括起来的字符串</li>
<li>值<code>value</code>可以是：<ul>
<li>数值（整数或浮点数）</li>
<li>字符串（在双引号中）</li>
<li>逻辑值（true 或 false）</li>
<li>数组（在中括号中）</li>
<li>对象（在大括号中）</li>
<li>null</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>JSON 语法是 JavaScript 语法的子集。</p>
<ul>
<li>数据是以键值对的形式存储的</li>
<li>不同数据项之间以逗号分隔</li>
<li>通过大括号来保存JSON对象</li>
<li>在JSON对象内容，数据的值也可以是数组，通过中括号来保存数组<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var employees = [</span><br><span class="line">&#123; &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; &#125;,</span><br><span class="line">&#123; &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; &#125;,</span><br><span class="line">&#123; &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;: &quot;Carter&quot; &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">// 访问</span><br><span class="line">employees[1].lastName; // Bush</span><br><span class="line"></span><br><span class="line">// 更改</span><br><span class="line">employees[0].lastName = &apos;Michael&apos;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>序列化与反序列化</p>
<ul>
<li><p>2个程序（或服务器、语言等）需要交互通信的时候，他们倾向于使用string字符串因为string在很多语言里解析的方式都差不多。复杂的数据结构经常需要用到，并且通过各种各样的中括号{}，小括号()，叫括号&lt;&gt;和空格来组成，这个字符串仅仅是按照要求规范好的字符。</p>
<p>为此，我们为了描述这些复杂的数据结构作为一个string字符串，制定了标准的规则和语法。JSON只是其中一种语法，它可以在string上下文里描述对象，数组，字符串，数字，布尔型和null，然后通过程序间传输，并且反序列化成所需要的格式。</p>
</li>
</ul>
</li>
<li><p>JSON适用于<code>string</code>上下文中。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 这是JSON字符串</span><br><span class="line">var foo = &apos;&#123; &quot;prop&quot;: &quot;val&quot; &#125;&apos;;</span><br><span class="line"> </span><br><span class="line">// 这是对象字面量</span><br><span class="line">var bar = &#123; &quot;prop&quot;: &quot;val&quot; &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>JSON方法：</p>
<ul>
<li><p><code>JSON.parse()</code> 方法用来解析JSON字符串，构造由字符串描述的JavaScript值或对象。提供可选的reviver函数用以在返回之前对所得到的对象执行变换(操作)。若传入的字符串不符合 <code>JSON</code> 规范，则会抛出 <code>SyntaxError</code> 异常。</p>
<ul>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JSON.parse(&quot;100&quot;) // 100</span><br><span class="line">JSON.parse(&quot;[]&quot;) // []</span><br><span class="line">JSON.parse(&quot;&#123;&#125;&quot;) // &#123;&#125;</span><br><span class="line">JSON.parse(&quot;true&quot;) // true</span><br><span class="line"></span><br><span class="line">var person = JSON.parse(&apos;&#123;&quot;name&quot;:&quot;tws&quot;&#125;&apos;)</span><br><span class="line">person.name // tws</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse" target="_blank" rel="noopener">JSON.parse()详述</a></p>
</li>
</ul>
</li>
<li><p><code>JSON.stringify()</code> 方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串</p>
<ul>
<li><p>示例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JSON.stringify(100) // &quot;100&quot;</span><br><span class="line">JSON.stringify(&apos;tws&apos;) // &quot;&quot;tws&quot;&quot;</span><br><span class="line">JSON.stringify([]) // &quot;[]&quot;</span><br><span class="line">JSON.stringify(&#123;&#125;) // &quot;&#123;&#125;&quot;</span><br><span class="line">JSON.stringify(true) // &quot;true&quot;</span><br><span class="line"></span><br><span class="line">JSON.stringify([&quot;true&quot;, true])</span><br><span class="line">// &quot;[&quot;true&quot;,true]&quot;</span><br><span class="line"></span><br><span class="line">JSON.stringify(&#123; name: &quot;tws&quot; &#125;)</span><br><span class="line">// &apos;&#123;&quot;name&quot;:&quot;tws&quot;&#125;&apos;</span><br></pre></td></tr></table></figure>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank" rel="noopener">JSON.stringify()详述</a></p>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2></li>
</ul>
</li>
</ul>
</li>
<li>Asynchronous JavaScript And XML是一种新的开发技术和设计模式，它可以创建更好、更快且交互性更强的 web 应用程序。Ajax 使用 JavaScript 在 web 浏览器与 web 服务器之间来发送和接收数据。通过与 web 服务器交换数据，而不是每当用户作出改变时重载整个 web 页面，Ajax 技术可以使网页更迅速地响应。</li>
<li>Ajax 使用 XML 和 HTTP 请求<ul>
<li>传统的 web 应用程序会把数据提交到 web 服务器（使用 HTML 表单）。在 web 服务器把数据处理完毕之后，会向用户返回一张完整的新网页。</li>
<li>由于每当用户提交输入，服务器就会返回新网页，传统的 web 应用程序往往运行缓慢，且越来越不友好。</li>
<li>通过 Ajax，web 应用程序<strong>无需重载网页，就可以发送并取回数据</strong>。完成这项工作，需要通过向服务器发送 HTTP 请求，并通过当服务器返回数据时使用 JavaScript 仅仅修改网页的某部分。</li>
<li>一般使用 JSON 作为接收服务器数据的格式。</li>
</ul>
</li>
<li>XHR: XMLHttpRequest, 是一种用于在 Web 浏览器和 Web 服务器间传输数据消息的 JavaScript API。</li>
<li>XHR 交互由两部分组成：请求和响应。</li>
<li>Ajax请求的主要回调函数：<ul>
<li><code>beforeSend</code>：在发送请求之前调用，并且传入一个XMLHttpRequest作为参数</li>
<li><code>dataFilter</code>：在请求成功之后调用。传入返回的数据以‘dataType’参数的值。并且必须返回新的数据传递给<code>success</code>的回调函数。</li>
<li><code>success</code>：在请求成功之后调用，传入返回的数据，以及包含成功代码的字符串</li>
<li><code>erroe</code>：在请求出错时调用，传入XMLHttpRequest对象，描述错误类型的字符串以及一个异常对象</li>
<li><code>complete</code>：当请求完成之后调用这个函数，无论成功失败，传入XMLHttpRequest，以及一个包含成功或者错误代码的字符串</li>
</ul>
</li>
<li>Ajax的优点<ul>
<li>页面无刷新，局部请求，用户体验良好</li>
<li>使用异步方式与服务器通信，具有更加迅速的响应能力<br>以前一些服务器的工作可以转移到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。</li>
</ul>
</li>
<li>Ajax的缺点<ul>
<li>Ajax不支持浏览器back按钮</li>
<li>安全问题, Ajax暴露了与服务器交互的细节</li>
<li>对搜索引擎的支持比较弱，不利于SEO</li>
<li>不容易调试</li>
</ul>
</li>
<li><p>创建<code>AJAX</code>的步骤</p>
<ol>
<li><p>创建<code>XMLHttpRequest</code>对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br></pre></td></tr></table></figure>
</li>
<li><p>准备请求.初始化该XMLHttpRequest对象，接受三个参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(method,url,async);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li>第一个参数表示请求类型的字符串，其值可以是<code>GET</code>或者<code>POST</code>。</li>
<li>第二个参数是要作为请求发送目标的<code>URL</code>。</li>
<li>第三个参数是<code>true</code>或<code>false</code>，表示请求是以异步还是同步的模式发出。（默认为<code>true</code>，一般不建议为<code>false</code>）。</li>
</ul>
<ol start="3">
<li>发送请求<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><p>一般情况下，使用Ajax提交的参数多是些简单的字符串，可以直接使用GET方法将要提交的参数写到open方法的url参数中，此时send方法的参数为null或为空。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;GET&quot;,demo.php?name=tsrot&amp;age=24,true);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果需要像 HTML 表单那样 POST 数据，请使用 setRequestHeader()来添加 HTTP 头。然后在send()方法中规定希望发送的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&quot;POST&quot;,demo.php,true);</span><br><span class="line">xhr.setRequestHeder(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded;charset=UTF-8&quot;);</span><br><span class="line">xhr.sen</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="4">
<li>处理响应<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange = function()&#123;</span><br><span class="line">    if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class="line">        console.log(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ul>
<li><code>onreadystatechange</code> ：当处理过程发生变化的时候执行下面的函数</li>
<li><code>readyState</code> ：ajax处理过程<ul>
<li><code>0</code>：请求未初始化（还没有调用 open()）。</li>
<li><code>1</code>：请求已经建立，但是还没有发送（还没有调用 send()）。</li>
<li><code>2</code>：请求已发送，正在处理中（通常现在可以从响应中获取内容头）。</li>
<li><code>3</code>：请求在处理中；通常响应中已有部分数据可用了，但是服务器还没有完成响应的生成。</li>
<li><code>4</code>：响应已完成；您可以获取并使用服务器的响应了。</li>
</ul>
</li>
<li><code>status</code>属性：<ul>
<li><code>200</code>:”OK”</li>
<li><code>404</code>: 未找到页面</li>
</ul>
</li>
<li><code>responseText</code>：获得字符串形式的响应数据</li>
<li><code>responseXML</code>：获得 XML形式的响应数据</li>
<li>对象转换为JSON格式使用<code>JSON.stringify()</code></li>
<li>json转换为对象格式用<code>JSON.parse()</code></li>
<li>返回值一般为json字符串，可以用<code>JSON.parse(xhr.responseText)</code>转化为对象</li>
</ul>
</li>
<li><p>如下创建了一个名为ajax的XHR对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var ajax = &#123;</span><br><span class="line">    request: function (url, method, callback, data) &#123;</span><br><span class="line">    var xhr = null;</span><br><span class="line">    xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.open(method, url, true);</span><br><span class="line">    if (method == &quot;post&quot;) &#123;</span><br><span class="line">        xhr.send(data);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        xhr.send(null);</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">        if (xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123;</span><br><span class="line">        callback(xhr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>其示例用法如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function myCallback(xhr)&#123; </span><br><span class="line">alert(xhr.responseText); </span><br><span class="line">&#125;</span><br><span class="line">ajax.request(“somefile.txt”,”get”,myCallback);</span><br><span class="line">ajax.request(“script.php”,”post”,myCallback,”first=John&amp;last=Smith”);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h2><ul>
<li><code>localStorage</code>主要是用来作为本地存储来使用的,解决了cookie存储空间不足的问题(cookie中每条cookie的存储空间为4k)，localStorage中一般浏览器支持的是5M大小，这个在不同的浏览器中localStorage会有所不同。</li>
<li><code>localStorage</code>只支持<code>String</code>类型的存储。</li>
<li><p><code>localstorage</code>的方法：</p>
<ul>
<li><p><code>localStorage.setItem(keyName, keyValue)</code>; 添加新的数据到Localstorage中存储</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem(&apos;name&apos;, &apos;tws&apos;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>localStorage.getItem(keyName)</code>; 返回指定keyName的Localstorage中存储的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.getItem(&apos;name&apos;); // &quot;tws&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>localStorage.removeItem(keyName)</code>; 从Localstorage中移除指定keyName的数据项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.removeItem(&apos;name&apos;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>localStorage.key(index)</code>; 返回指定顺序的Localstorage中存储的键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">localStorage.key(1); // &quot;name&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>localStorage.clear()</code>; 清除所有的本地Localstorage存储</p>
</li>
<li><p>也可以使用之前对象里的增加/修改属性方法来添改Localstorage数据</p>
<ul>
<li><p>点表示法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//写入a字段</span><br><span class="line">localstorage[&quot;a&quot;]=1;</span><br></pre></td></tr></table></figure>
</li>
<li><p>括号表示法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//写入b字段</span><br><span class="line">localstorage.b=1;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>localStorage</code>的优势</p>
<ul>
<li><code>localStorage</code>拓展了cookie的4K限制，为前端数据存储提供了新的思路</li>
<li><code>localStorage</code>会可以将第一次请求的数据直接存储到本地，这个相当于一个5M大小的针对于前端页面的数据库，相比于cookie可以节约带宽</li>
</ul>
</li>
<li><code>localstorage</code>的不足<ul>
<li>不同浏览器的存储大小不统一，并且在IE8以上的IE版本才支持<code>localStorage</code>这个属性</li>
<li><code>localStorage</code>的值类型限定为<code>String</code>类型，许多使用场景下会有限制</li>
<li><code>localStorage</code>在浏览器的隐私模式下面是不可读取的</li>
<li><code>localStorage</code>本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/01/notes_of_js_2/" data-id="cjquy665l000hxkowiunajrhg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-relative" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/29/relative/" class="article-date">
  <time datetime="2018-11-29T14:18:18.004Z" itemprop="datePublished">2018-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/29/relative/">relative.html</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
<meta charset="utf-8"> 
<title>relative</title> 
<style>
h2.pos_top
{
	position:relative;
	top:-50px;
}
</style>
</head>

<body>
<h2>这是一个没有定位的标题</h2>
<h2 class="pos_top">这个标题是根据其正常位置向上移动</h2>
<p><b>注意:</b> 即使相对定位元素的内容是移动,预留空间的元素仍保存在正常流动。</p>
</body>

</html>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/29/relative/" data-id="cjquy65xy0001xkow4i93ykvz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-visibility" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/29/visibility/" class="article-date">
  <time datetime="2018-11-29T14:10:36.183Z" itemprop="datePublished">2018-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/29/visibility/">visibility.html</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
<style>
h1.visible {visibility:visible}
h1.hidden {visibility:hidden}
</style>
</head>

<body>
<h1 class="visible">This is a visible heading</h1>
<h1 class="hidden">This is an invisible heading</h1>
<p>Notice that the invisible heading still takes up space.</p>
</body>

</html>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/29/visibility/" data-id="cjquy660x000bxkow4beadx6b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/13/summary_week5_2/">总结—第一阶段第四周</a>
          </li>
        
          <li>
            <a href="/2018/12/29/summary_week3_2/">总结—JS进阶第三周</a>
          </li>
        
          <li>
            <a href="/2018/12/23/summary_week2_2/">总结—JS进阶第二周</a>
          </li>
        
          <li>
            <a href="/2018/12/15/summary_week1_2/">总结—JavaScript进阶第一周</a>
          </li>
        
          <li>
            <a href="/2018/12/09/notes_of_advanced_js/">JavaScript进阶笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Song Nan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>