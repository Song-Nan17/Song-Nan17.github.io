<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>宋博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="宋博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="宋博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="宋博客">
  
    <link rel="alternate" href="/atom.xml" title="宋博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">宋博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">我爱学习</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-java_exception" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/25/java_exception/" class="article-date">
  <time datetime="2019-01-25T13:59:23.975Z" itemprop="datePublished">2019-01-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/25/java_exception/">Java异常</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java异常"><a href="#Java异常" class="headerlink" title="Java异常"></a>Java异常</h1><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>程序运行时，发生的不被期望的事件，它阻止了程序按照程序员的预期正常执行，这就是异常。在java中，阻止当前方法或作用域的情况，称之为异常。</p>
<h2 id="异常和错误"><a href="#异常和错误" class="headerlink" title="异常和错误"></a>异常和错误</h2><p>Java中的所有异常都是由<code>Throwable</code>类的子类生成的对象，所有的异常类都是<code>Throwable</code>类的子类或子类的子类。<code>Throwable</code>类是<code>Object</code>类的直接子类，<code>Error</code>类和<code>Exception</code>类是<code>Throwable</code>类的两个直接子类。</p>
<h3 id="Error类："><a href="#Error类：" class="headerlink" title="Error类："></a>Error类：</h3><p>不能处理的系统错误类，如内存溢出、虚拟机错误、栈溢出等。这类错误一般与硬件有关，与程序本身无关，通常由系统进行处理，程序本身无法捕获和处理。</p>
<p>包括虚拟机错误(<code>VirtualMachineError</code>)和线程死锁(<code>ThreadDeath</code>)，一旦<code>Error</code>出现了，程序就彻底的挂了。</p>
<p>常见的<code>error</code>有：<code>NotClassDeFountError</code>（类未定义错误），<code>OutofMemoryError</code>(内存溢出错误)，<code>StackOverFlowError</code>(栈溢出错误)。</p>
<h3 id="Exception类："><a href="#Exception类：" class="headerlink" title="Exception类："></a>Exception类：</h3><p>即常说的异常。</p>
<p>异常分为运行时异常(<code>RuntimeException</code>)和检查型异常(<code>CheckedException</code>)。</p>
<ul>
<li><p>检查型异常：java编译器对检查性异常会要求我们进行<code>catch</code>，必须得进行捕获，否则编译不过去。java认为检查性异常都可以被处理，所以必须显示的处理检查型异常。常见的检查性异常有<code>IOException</code>，<code>SqlException</code>。</p>
</li>
<li><p>运行时异常：程序员<strong>不需要</strong>去手动的<code>catch</code>。当程序中出现运行时异常时，<code>java</code>虚拟机会进行处理（就算我们没写异常捕获语句运行时也会抛出错误！！），此类异常的出现绝大数情况是代码本身有问题应该从逻辑上去解决并改进代码。常见的运行时异常有：空指针异常、数组下标越界异常、类型转换异常、算术异常等。</p>
</li>
<li><p>此外，还有自定义异常：为了表示应用程序的一些特定错误类型，为代码可能发生的一个或多个问题提供新的确切的含义。由软件开发者自己根据系统的需求而定义。</p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>总结：</p>
</li>
<li>错误是系统错误或者资源错误，是不可控制的。</li>
<li>异常是程序错误引起的，检查型异常在程序中必须被程序员<code>try</code>，<code>catch</code>的进行显示处理，而运行时异常不需要，它会有jvm进行处理。<h2 id="几种常见异常"><a href="#几种常见异常" class="headerlink" title="几种常见异常"></a>几种常见异常</h2><h3 id="检查型异常"><a href="#检查型异常" class="headerlink" title="检查型异常"></a>检查型异常</h3></li>
<li>Java.alng.NullPointerException<br>这个异常的解释是 “程序遇上了空指针“，简单地说就是调用了未经初始化的对象或者是不存在的对象，这个错误经常出现在创建图片，调用数组这些操作中，比如图片未经初始化，或者图片创建时的路径错误等等。对数组操作中出现空指针，很多情况下是即把数组的初始化和数组元素的初始化混淆起来了。数组的初始化是对数组分配需要的空间，而初始化后的数组，其中的元素并没有实例化，依然是空的，所以还需要对每个元素都进行初始化（如果要调用的话）。解决这个问题的方法是在使用前进行判空比较。</li>
<li>java.lang.ClassNotFoundException<br>这个异常的解释是 “指定的类不存在 ，这里主要考虑一下类的名称和路径是否正确即可。</li>
<li>java.lang.ArithmeticException<br>这个异常的解释是 “数学运算异常”，比如程序中出现(1/0)除以零这样的运算就会出这样的异常，对这种异常，我们就要好好检查一下自己程序中涉及到数学运算的地方，公式是不是有不妥了。</li>
<li>java.lang.ArrayIndexOutOfBoundsException<br>这个异常的解释是 “数组下标越界 “，在调用数组的时候一定要认真检查，看自己调用的下标是不是超出了数组的范围。</li>
</ul>
<p>一般来说，显式（即直接用常数当下标）调用不太容易出这样的错，但隐式（即用变量表示下标）调用就经常出错了。</p>
<p>还有一种情况，是程序中定义的数组的长度是通过某些特定方法决定的，不是事先声明的，这个时候，最好先查看一下数组的<code>length</code>，以免出现这个异常</p>
<ul>
<li>java.lang.IllegalArgumentException<br>这个异常的解释是 “方法的参数错误 “，很多J2ME的类库中的方法在一些情况下都会引发这样的错误，比如音量调节方法中的音量参数如果写成负数就会出现这个异常，再比如<code>g.setColor(int red,int green,int blue)</code>这个方法中的三个值，如果有超过<code>255</code>的也会出现这个异常，因此一旦发现这个异常，我们要做的，就是赶紧去检查一下方法调用中的参数传递是不是出现了错误。</li>
<li>java.lang.IllegalAccessException<br>这个异常的解释是 “没有访问权限 “，当应用程序要调用一个类，但当前的方法即没有对该类的访问权限便会出现这个异常。对程序中用了Package的情况下要注意这个异常。</li>
<li>java.lang.IncompatibleClassChangeError<br>“不兼容的类变化错误”，当正在执行的方法所依赖的类定义发生了不兼容的改变时，抛出该异常。一般在修改了应用中的某些类的声明定义而没有对整个应用重新编译而直接运行的情况下，容易引发该错误。</li>
<li>java.lang.InstantiationError<br>“实例化错误”，当一个应用试图通过Java的new操作符构造一个抽象类或者接口时抛出该异常。</li>
<li>java.lang.LinkageError<br>“链接错误”，该错误及其所有子类指示某个类依赖于另外一些类，在该类编译之后，被依赖的类改变了其类定义而没有重新编译所有的类，进而引发错误的情况。</li>
<li>java.lang.StackOverflowError<br>“堆栈溢出错误”，当一个应用递归调用的层次太深而导致堆栈溢出时抛出该错误。<h2 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h2>异常处理就是在异常发生的地方，通过有效的处理手段，来增加系统的稳定性，不让应用程序中断。通常有两种方式，处理异常和声明异常。</li>
<li>处理异常：表示这个异常就地可以解决，一般通过<code>try...catch...</code>语句块来解决。</li>
<li>声明异常：表示这个异常在异常发生的地方无法解决，将其抛出去(用<code>throw</code>将锅甩给他人)，并在方法定义中予以声明。<h3 id="处理异常-1"><a href="#处理异常-1" class="headerlink" title="处理异常"></a>处理异常</h3><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4>使用 <code>try</code> 和<code>catch</code> 关键字可以捕获异常。<code>try</code>/<code>catch</code> 代码块放在异常可能发生的地方。</li>
</ul>
<p><code>try</code>/<code>catch</code>代码块中的代码称为保护代码，使用 <code>try</code>/<code>catch</code> 的语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">   // 程序代码</span><br><span class="line">&#125;catch(ExceptionName e1)</span><br><span class="line">&#123;</span><br><span class="line">   //Catch 块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Catch</code> 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，<code>try</code> 后面的 <code>catch</code> 块就会被检查。<br>如果发生的异常包含在 <code>catch</code>块中，异常会被传递到该 <code>catch</code> 块，这和传递一个参数到方法是一样。</p>
<p>实例:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 文件名 : ExcepTest.java</span><br><span class="line">import java.io.*;</span><br><span class="line">public class ExcepTest&#123;</span><br><span class="line"> </span><br><span class="line">   public static void main(String args[])&#123;</span><br><span class="line">      try&#123;</span><br><span class="line">         int a[] = new int[2];</span><br><span class="line">         System.out.println(&quot;Access element three :&quot; + a[3]);</span><br><span class="line">      &#125;catch(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">         System.out.println(&quot;Exception thrown  :&quot; + e);</span><br><span class="line">      &#125;</span><br><span class="line">      System.out.println(&quot;Out of the block&quot;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的例子中声明有两个元素的一个数组，当代码试图访问数组的第三个元素的时候就会抛出一个异常，<code>ArrayIndexOutOfBoundsException</code>。</p>
<p>以上代码编译运行输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3</span><br><span class="line">Out of the block</span><br></pre></td></tr></table></figure></p>
<h4 id="多重捕获块"><a href="#多重捕获块" class="headerlink" title="多重捕获块"></a>多重捕获块</h4><p>一个 <code>try</code> 代码块后面跟随<strong>多个</strong><code>catch</code>代码块的情况就叫多重捕获。</p>
<p>多重捕获块的语法如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">   // 程序代码</span><br><span class="line">&#125;catch(异常类型1 异常的变量名1)&#123;</span><br><span class="line">  // 程序代码</span><br><span class="line">&#125;catch(异常类型2 异常的变量名2)&#123;</span><br><span class="line">  // 程序代码</span><br><span class="line">&#125;catch(异常类型2 异常的变量名2)&#123;</span><br><span class="line">  // 程序代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码段包含了 <code>3</code> 个<code>catch</code>块。</p>
<ul>
<li>可以在 try 语句后面添加任意数量的 <code>catch</code> 块。</li>
<li>如果保护代码中发生异常，异常被抛给第一个 <code>catch</code> 块。</li>
<li>如果抛出异常的数据类型与 <code>ExceptionType1</code> 匹配，它在这里就会被捕获。</li>
<li>如果不匹配，它会被传递给第二个 <code>catch</code> 块。</li>
<li>如此，直到异常被捕获或者通过所有的 <code>catch</code> 块。<h4 id="finally块"><a href="#finally块" class="headerlink" title="finally块"></a>finally块</h4></li>
<li><code>finally</code> 关键字用来创建在 <code>try</code> 代码块后面执行的代码块。</li>
<li>无论是否发生异常，<code>finally</code> 代码块中的代码总会被执行。</li>
<li>在 <code>finally</code>代码块中，可以运行清理类型等收尾善后性质的语句。</li>
<li><code>finally</code> 代码块出现在 <code>catch</code> 代码块最后，语法如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">  // 程序代码</span><br><span class="line">&#125;catch(异常类型1 异常的变量名1)&#123;</span><br><span class="line">  // 程序代码</span><br><span class="line">&#125;catch(异常类型2 异常的变量名2)&#123;</span><br><span class="line">  // 程序代码</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">  // 程序代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ExcepTest&#123;</span><br><span class="line">  public static void main(String args[])&#123;</span><br><span class="line">    int a[] = new int[2];</span><br><span class="line">    try&#123;</span><br><span class="line">       System.out.println(&quot;Access element three :&quot; + a[3]);</span><br><span class="line">    &#125;catch(ArrayIndexOutOfBoundsException e)&#123;</span><br><span class="line">       System.out.println(&quot;Exception thrown  :&quot; + e);</span><br><span class="line">    &#125;</span><br><span class="line">    finally&#123;</span><br><span class="line">       a[0] = 6;</span><br><span class="line">       System.out.println(&quot;First element value: &quot; +a[0]);</span><br><span class="line">       System.out.println(&quot;The finally statement is executed&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上实例编译运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception thrown  :java.lang.ArrayIndexOutOfBoundsException: 3</span><br><span class="line">First element value: 6</span><br><span class="line">The finally statement is executed</span><br></pre></td></tr></table></figure></p>
<h4 id="注意下面事项："><a href="#注意下面事项：" class="headerlink" title="注意下面事项："></a>注意下面事项：</h4><ul>
<li><code>catch</code> 不能独立于 <code>try</code> 存在。</li>
<li>在 <code>try</code>/<code>catch</code> 后面添加 <code>finally</code> 块并非强制性要求的。</li>
<li><code>try</code> 代码后不能既没 catch 块也没 <code>finally</code> 块。</li>
<li><code>try</code>, <code>catch</code>, <code>finally</code> 块之间不能添加任何代码。<h3 id="声明异常"><a href="#声明异常" class="headerlink" title="声明异常"></a>声明异常</h3>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 <code>throws</code> 关键字来声明。<code>throws</code> 关键字放在方法签名的尾部。</li>
</ul>
<p>也可以使用 <code>throw</code> 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p>
<p>下面方法的声明抛出一个 <code>RemoteException</code> 异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class className</span><br><span class="line">&#123;</span><br><span class="line">  public void deposit(double amount) throws RemoteException</span><br><span class="line">  &#123;</span><br><span class="line">    // Method implementation</span><br><span class="line">    throw new RemoteException();</span><br><span class="line">  &#125;</span><br><span class="line">  //Remainder of class definition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一个方法可以声明抛出多个异常，多个异常之间用<strong>逗号</strong>隔开。如下<br>抛出 <code>RemoteException</code> 和 <code>InsufficientFundsException</code>异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">public class className</span><br><span class="line">&#123;</span><br><span class="line">   public void withdraw(double amount) throws RemoteException,</span><br><span class="line">                              InsufficientFundsException</span><br><span class="line">   &#123;</span><br><span class="line">       // Method implementation</span><br><span class="line">   &#125;</span><br><span class="line">   //Remainder of class definition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/25/java_exception/" data-id="cjrc5777t000gqgown3opsxxr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-notes_of_this" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/20/notes_of_this/" class="article-date">
  <time datetime="2019-01-20T14:56:13.826Z" itemprop="datePublished">2019-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/20/notes_of_this/">this, call(), apply() 和bind()</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于<code>this</code>，以前只是在定义一个指定类型的对象一节，了解到<code>this</code>就是代码运行时的对象，指向调用函数的对象。周六的测评有道<code>this</code>和箭头函数的题，以及最后一道题<code>call</code>, <code>apply</code>和<code>bind</code>方法，都和<code>this</code>指向有。</p>
<h1 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h1><p>##全局环境下<br>在全局环境下，<code>this</code> 始终指向全局对象（<code>window</code>）, 无论是否严格模式；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(this.document === document); // true</span><br><span class="line"></span><br><span class="line">// 在浏览器中，全局对象为 window 对象：</span><br><span class="line">console.log(this === window); // true</span><br><span class="line"></span><br><span class="line">this.a = 37;</span><br><span class="line">console.log(window.a); // 37</span><br></pre></td></tr></table></figure></p>
<h2 id="函数上下文调用"><a href="#函数上下文调用" class="headerlink" title="函数上下文调用"></a>函数上下文调用</h2><h3 id="函数直接调用"><a href="#函数直接调用" class="headerlink" title="函数直接调用"></a>函数直接调用</h3><p>普通函数内部的<code>this</code>分两种情况，<strong>严格模式</strong>和<strong>非严格模式</strong>。</p>
<ul>
<li><p>非严格模式下，<code>this</code> 默认指向全局对象<code>window</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1() === window; // true</span><br></pre></td></tr></table></figure>
</li>
<li><p>严格模式下， <code>this</code>为<code>undefined</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f2()&#123;</span><br><span class="line">  &quot;use strict&quot;; // 这里是严格模式</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2() === undefined; // true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="对象中的this"><a href="#对象中的this" class="headerlink" title="对象中的this"></a>对象中的this</h3><p>对象内部方法的<code>this</code>指向<strong>调用这些方法的对象</strong></p>
<ol>
<li>函数的定义位置不影响其<code>this</code>指向，<code>this</code>指向只和调用函数的对象有关。</li>
<li>多层嵌套的对象，内部方法的<code>this</code>指向离被调用函数最近的对象（window也是对象，其内部对象调用方法的this指向内部对象， 而非window）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//1</span><br><span class="line"></span><br><span class="line">var o = &#123;</span><br><span class="line">  prop: 37,</span><br><span class="line">  f: function() &#123;</span><br><span class="line">    return this.prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(o.f());  //37</span><br><span class="line">var a = o.f;</span><br><span class="line">console.log(a()):  //undefined</span><br><span class="line"></span><br><span class="line">var o = &#123;prop: 37&#125;;</span><br><span class="line"></span><br><span class="line">function independent() &#123;</span><br><span class="line">  return this.prop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f = independent;</span><br><span class="line"></span><br><span class="line">console.log(o.f()); // 37</span><br><span class="line"></span><br><span class="line">//2</span><br><span class="line"></span><br><span class="line">o.b = &#123;</span><br><span class="line">  g: independent,</span><br><span class="line">  prop: 42</span><br><span class="line">&#125;;</span><br><span class="line">console.log(o.b.g()); // 42</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="原型链中this"><a href="#原型链中this" class="headerlink" title="原型链中this"></a>原型链中this</h3><p>原型链中的方法的<code>this</code>仍然指向调用它的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">  f : function()&#123; </span><br><span class="line">    return this.a + this.b; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">var p = Object.create(o);</span><br><span class="line">p.a = 1;</span><br><span class="line">p.b = 4;</span><br><span class="line"></span><br><span class="line">console.log(p.f()); // 5</span><br></pre></td></tr></table></figure></p>
<p>在<code>p</code>中没有属性<code>f</code>，当执行<code>p.f()</code>时，会查找<code>p</code>的原型链，找到<code>f</code> 函数并执行，但函数内部<code>this</code>指向对象 <code>p</code>,只需记住谁调用指向谁。</p>
<ul>
<li>以上对于函数作为<code>getter</code> &amp; <code>setter</code> 调用时同样适用。(<strong>后续再去了解</strong>)</li>
</ul>
<h3 id="构造函数中this"><a href="#构造函数中this" class="headerlink" title="构造函数中this"></a>构造函数中this</h3><p>构造函数中的<code>this</code>与被创建的新对象绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function C()&#123;</span><br><span class="line">  this.a = 37;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = new C();</span><br><span class="line">console.log(o.a); // 37 o = C &#123;a:37&#125;</span><br><span class="line"></span><br><span class="line">function C2()&#123;</span><br><span class="line">  this.a = 37;</span><br><span class="line">  return &#123;a:38&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = new C2();</span><br><span class="line">console.log(b.a); // 38 b=&#123;a:38&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="call-amp-apply"><a href="#call-amp-apply" class="headerlink" title="call &amp; apply"></a>call &amp; apply</h3><p>当函数通过Function对象的原型中继承的方法<code>call()</code> 和 <code>apply()</code> 方法调用时， 其函数内部的<code>this</code>值可绑定到 <code>call()</code> &amp; <code>apply()</code> 方法指定的第一个对象上， 如果第一个参数不是对象，JavaScript内部会尝试将其转换成对象然后指向它。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function add(c, d)&#123;</span><br><span class="line">  return this.a + this.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o = &#123;a:1, b:3&#125;;</span><br><span class="line"></span><br><span class="line">add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16</span><br><span class="line"></span><br><span class="line">add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34</span><br><span class="line"></span><br><span class="line">function tt() &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;</span><br><span class="line">// 返回对象见下图</span><br><span class="line">tt.call(5);  </span><br><span class="line">tt.call(&apos;asd&apos;);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://ww1.sinaimg.cn/large/a85d55ddly1fzdkwttbj6j2084087dft.jpg" alt=""></p>
<h3 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind 方法"></a>bind 方法</h3><p><code>bind</code>方法在ES5引入， 在<code>Function</code>的原型链上， <code>Function.prototype.bind</code>。通过<code>bind</code>方法绑定后， 函数将被永远绑定在其第一个参数对象上， 而无论其在什么情况下被调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">  return this.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = f.bind(&#123;a:&quot;azerty&quot;&#125;);</span><br><span class="line">console.log(g()); // azerty</span><br><span class="line"></span><br><span class="line">var o = &#123;a:37, f:f, g:g&#125;;</span><br><span class="line">console.log(o.f(), o.g()); // 37, azerty</span><br></pre></td></tr></table></figure></p>
<h3 id="DOM-事件处理函数中的-this-amp-内联事件中的-this-后续再使用html实例理解"><a href="#DOM-事件处理函数中的-this-amp-内联事件中的-this-后续再使用html实例理解" class="headerlink" title="DOM 事件处理函数中的 this &amp; 内联事件中的 this(后续再使用html实例理解)"></a>DOM 事件处理函数中的 this &amp; 内联事件中的 this(后续再使用html实例理解)</h3><ul>
<li>DOM事件处理函数</li>
</ul>
<p>当函数被当做监听事件处理函数时， 其 <code>this</code> 指向触发该事件的元素 （针对于<code>addEventListener</code>事件）</p>
<ul>
<li><p>内联事件<br>内联事件中的<code>this</code>指向分两种情况：</p>
<ul>
<li>当代码被内联处理函数调用时，它的<code>this</code>指向监听器所在的DOM元素</li>
<li>当代码被包括在函数内部执行时，其<code>this</code>指向等同于 <strong>函数直接调用</strong>的情况，即在非严格模式指向全局对象<code>window</code>， 在严格模式指向<code>undefined</code><h3 id="setTimeout-amp-setInterval"><a href="#setTimeout-amp-setInterval" class="headerlink" title="setTimeout &amp; setInterval"></a>setTimeout &amp; setInterval</h3>对于延时函数内部的回调函数的<code>this</code>指向全局对象<code>window</code>（可以通过<code>bind</code>方法改变其内部函数的this指向）<br>看下边代码及截图<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//默认情况下代码</span><br><span class="line">function Person() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();//3秒后返回 window 对象</span><br><span class="line">==============================================</span><br><span class="line">//通过bind绑定</span><br><span class="line">function Person() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setTimeout((function() &#123;</span><br><span class="line">        console.log(this);</span><br><span class="line">    &#125;).bind(this), 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();//3秒后返回构造函数新生成的对象 Person&#123;...&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="headerlink" title="箭头函数中的 this"></a>箭头函数中的 this</h3><p>由于箭头函数不绑定<code>this</code>， 它会捕获其所在（即定义的位置）上下文的<code>this</code>值， 作为自己的<code>this</code>值，</p>
<p>因为箭头函数可以捕获其所在上下文的this值 所以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Person() &#123;  </span><br><span class="line">    this.age = 0;  </span><br><span class="line">    setInterval(() =&gt; &#123;</span><br><span class="line">        // 回调里面的 `this` 变量就指向了期望的那个对象 Person 了</span><br><span class="line">        this.age++;</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p = new Person();</span><br></pre></td></tr></table></figure></p>
<p>下图可以看到，在setTimeout中的<code>this</code>指向了构造函数新生成的对象，而普通函数指向了全局<code>window</code>对象<br><img src="http://ww1.sinaimg.cn/large/a85d55ddly1fzdl7sy5hfj20dm06qmx4.jpg" alt=""></p>
<ol>
<li><p><code>call()</code> / <code>apply()</code> / <code>bind()</code> 方法对<strong>于箭头函数来说只是传入参数,对它的 <code>this</code> 毫无影响</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var adder = &#123;</span><br><span class="line">  base : 1,</span><br><span class="line">    </span><br><span class="line">  add : function(a) &#123;</span><br><span class="line">    var f = v =&gt; v + this.base;</span><br><span class="line">    return f(a);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  addThruCall: function inFun(a) &#123;</span><br><span class="line">    var f = v =&gt; v + this.base;</span><br><span class="line">    var b = &#123;</span><br><span class="line">      base : 2</span><br><span class="line">    &#125;;</span><br><span class="line">            </span><br><span class="line">    return f.call(b, a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(adder.add(1));         // 输出 2</span><br><span class="line">console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3，其内部的this并没有因为call() 而改变，其this值仍然为函数inFun的this值，指向对象adder</span><br></pre></td></tr></table></figure>
</li>
<li><p>考虑到 this 是词法层面上的，严格模式中与 <code>this</code> 相关的规则都将被忽略。（可以<strong>忽略是否在严格模式下</strong>的影响）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var f = () =&gt; &#123;&apos;use strict&apos;; return this&#125;;</span><br><span class="line">var p = () =&gt; &#123; return this&#125;;</span><br><span class="line">console.log(1,f() === window);</span><br><span class="line">console.log(2,f() === p());</span><br><span class="line">//1 true</span><br><span class="line">//2 true</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="如果将箭头函数当做一个方法使用"><a href="#如果将箭头函数当做一个方法使用" class="headerlink" title="如果将箭头函数当做一个方法使用"></a>如果将箭头函数当做一个方法使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">  i: 10,</span><br><span class="line">  b: () =&gt; console.log(this.i, this),</span><br><span class="line">  c: function() &#123;</span><br><span class="line">    console.log( this.i, this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.b();  // undefined window&#123;...&#125;</span><br><span class="line">obj.c();  // 10 Object &#123;...&#125;</span><br></pre></td></tr></table></figure>
<p><strong>作为方法的箭头函数this指向全局window对象，而普通函数则指向调用它的对象</strong></p>
<p>所以，对于测评的这道题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> window.name = &quot;bar&quot;;</span><br><span class="line">const object = &#123;</span><br><span class="line">  name: &quot;foo&quot;,</span><br><span class="line">  hi: function() &#123;</span><br><span class="line">    console.assert(this.name === &quot;foo&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  hello: () =&gt;  &#123;</span><br><span class="line">    console.assert(this.name === &quot;foo&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">object.hi(); //正常or报错？</span><br><span class="line">object.hello(); //正常or报错？</span><br></pre></td></tr></table></figure></p>
<p>对于<code>object.hi()</code>,<code>this</code>指向<code>object</code>,<code>this.name=&quot;foo&quot;</code>,而对于<code>object.hello()</code>,<code>this</code>指向全局对象，<code>this.name=&quot;bar&quot;</code></p>
<h1 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call(), apply(), bind()"></a>call(), apply(), bind()</h1><p>从上面<code>this</code>指向的部分例子中就可以看出，<code>apply</code> 、 <code>call</code> 、<code>bind</code> 三者都是用来改变函数的this对象的指向的。</p>
<h2 id="apply-amp-call"><a href="#apply-amp-call" class="headerlink" title="apply &amp; call"></a>apply &amp; call</h2><p>其中<code>call</code>和<code>apply</code>更相似，先看下它们俩的语法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fun.call(thisArg, arg1, arg2, ...)</span><br><span class="line">fun.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure></p>
<p>其中<code>thisArg</code>为函数<code>fun</code>运行时使用的<code>this</code>值，如果这个函数处于非严格模式下，则指定为 <code>null</code> 或 <code>undefined</code> 时会自动替换为指向全局对象，原始值会被包装。而<code>arg1, arg2, ...</code>和<code>[argsArray]</code>均为传递给函数<code>fun</code>的参数。<br>由语法规范可以看出，<code>call()</code>方法接受的是参数列表，而<code>apply()</code>方法接受的是一个参数数组。</p>
<p>出了<code>this指向</code>中一类的例子外，在一个子构造函数中，可以通过调用父构造函数的<code>call</code>或<code>apply</code>方法来实现继承<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Product(name, price) &#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Food(name, price) &#123;</span><br><span class="line">  Product.call(this, name, price);</span><br><span class="line">  this.category = &apos;food&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Toy(name, price) &#123;</span><br><span class="line">  Product.apply(this, [name, price]);</span><br><span class="line">  this.category = &apos;toy&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cheese = new Food(&apos;feta&apos;, 5);</span><br><span class="line">var fun = new Toy(&apos;robot&apos;, 40);</span><br></pre></td></tr></table></figure></p>
<p><img src="http://ww1.sinaimg.cn/large/a85d55ddly1fzdltxlz62j20bv0a6aa7.jpg" alt=""></p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h2><p>而<code>bind()</code>的不同之处在于它会创建一个新函数。</p>
<p>bind()方法<strong>创建一个新的函数</strong>，在调用时设置this关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。</p>
<p>例如，在 <code>f()</code> 函数上调用<code>bind()</code> 方法并传入参数 <code>obj</code> ，即 <code>f.bind(obj)</code> ，这将返回一个新函数, 新函数会把原始的函数 <code>f()</code> 当做 <code>obj</code> 的方法来调用,就像 <code>obj.f()</code> 似的，当然这时 <code>f()</code> 函数中的 <code>this</code> 对象指向的是 obj 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(y,z)&#123;</span><br><span class="line">    return this.x+y+z;</span><br><span class="line">&#125;</span><br><span class="line">var m=f.bind(&#123;x:1&#125;,2); </span><br><span class="line">console.log(m(3));  // 6</span><br></pre></td></tr></table></figure>
<p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure></p>
<p><code>thisArg</code>是调用绑定函数时作为this参数传递给目标函数的值。 如果使用<code>new</code>运算符构造绑定函数，则忽略该值。<code>bind</code>传递参数和<code>call</code>相同，接受的是参数列表。</p>
<ul>
<li>简单使用情形一<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o=&#123;</span><br><span class="line">    f: function () &#123;</span><br><span class="line">        var self=this;</span><br><span class="line">        var fff=function() &#123;</span><br><span class="line">            console.log(self.value);  //此时 this 指向的是全局作用域 global/window，因此需要使用 self 指向对象o</span><br><span class="line">        &#125;;</span><br><span class="line">        fff();</span><br><span class="line">    &#125;,</span><br><span class="line">    value: &quot;Hello World!&quot;</span><br><span class="line">&#125;;</span><br><span class="line">o.f(); // Hello World!</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上例把 <code>this</code> 赋值给了中间变量 <code>self</code>来保持 <code>this</code> 上下文，这样在内部嵌套的函数中能够使用 <code>self</code> 访问到对象<code>o</code>，否则仍使用 <code>this.value</code>，内部嵌套函数的<code>this</code>此时指向的是全局作用域，最后的输出将会是 <code>undefined</code>，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o=&#123;</span><br><span class="line">    f: function () &#123;</span><br><span class="line">        var self=this;</span><br><span class="line">        var fff=function() &#123;</span><br><span class="line">            console.log(this.value); </span><br><span class="line">        &#125;;</span><br><span class="line">        fff();</span><br><span class="line">    &#125;,</span><br><span class="line">    value: &quot;Hello World!&quot;</span><br><span class="line">&#125;;</span><br><span class="line">o.f(); // undefined</span><br></pre></td></tr></table></figure></p>
<p>但是，如果使用<code>bind()</code>函数，将<code>fff</code>函数的绑定在对象<code>o</code>中，即将<code>fff()</code>函数内部的 <code>this</code> 对象绑定为对象 <code>o</code>，那么此时 <code>this.value</code> 是存在的。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o=&#123;</span><br><span class="line">    f: function () &#123;</span><br><span class="line">        var self=this;</span><br><span class="line">        var fff=function() &#123;</span><br><span class="line">            console.log(this.value); // bind(this) 中 this 指向的是o，这里也可直接写成 bind(o)</span><br><span class="line">        &#125;.bind(this);</span><br><span class="line">        fff();</span><br><span class="line">    &#125;,</span><br><span class="line">    value: &quot;Hello World!&quot;</span><br><span class="line">&#125;;</span><br><span class="line">o.f(); // Hello World！</span><br></pre></td></tr></table></figure></p>
<p><code>bind</code>只能使用一次，多次使用无效：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var bar = function()&#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line">var foo = &#123;</span><br><span class="line">    x:3</span><br><span class="line">&#125;</span><br><span class="line">var sed = &#123;</span><br><span class="line">    x:4</span><br><span class="line">&#125;</span><br><span class="line">var func = bar.bind(foo).bind(sed);</span><br><span class="line">func(); // 3</span><br><span class="line"> </span><br><span class="line">var fiv = &#123;</span><br><span class="line">    x:5</span><br><span class="line">&#125;</span><br><span class="line">var func = bar.bind(foo).bind(sed).bind(fiv);</span><br><span class="line">func(); // 3</span><br></pre></td></tr></table></figure></p>
<p>原因是，在<code>Javascript</code>中，多次 <code>bind()</code> 是无效的。更深层次的原因， <code>bind()</code> 的实现，相当于使用函数在内部包了一个 <code>call</code> /<code>apply</code> ，第二次 <code>bind()</code> 相当于再包住第一次<code>bind()</code> ,故第二次以后的 <code>bind</code> 是无法生效的。</p>
<h3 id="apply、call、bind比较"><a href="#apply、call、bind比较" class="headerlink" title="apply、call、bind比较"></a>apply、call、bind比较</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    x: 81,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">var foo = &#123;</span><br><span class="line">    getX: function() &#123;</span><br><span class="line">        return this.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">console.log(foo.getX.bind(obj)());  //81</span><br><span class="line">console.log(foo.getX.call(obj));    //81</span><br><span class="line">console.log(foo.getX.apply(obj));   //81</span><br></pre></td></tr></table></figure>
<p><code>apply</code> 、 <code>call</code> 、<code>bind</code> 三者都是用来改变函数的<code>this</code>对象的指向的；<br><code>apply</code> 、 <code>call</code> 、<code>bind</code> 三者第一个参数都是<code>this</code>要指向的对象，也就是想指定的上下文；<br><code>apply</code> 、 <code>call</code> 、<code>bind</code> 三者都可以利用后续参数传参；<br><code>bind</code> 是返回对应函数，便于稍后调用；<code>apply</code> 、<code>call</code> 则是立即调用 。<br><img src="http://ww1.sinaimg.cn/large/a85d55ddly1fzdmexhrrsj20og0aidgi.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/20/notes_of_this/" data-id="cjrc5778e000jqgowqp0zr2xl" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-summary_of_exam" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/19/summary_of_exam/" class="article-date">
  <time datetime="2019-01-19T15:12:43.045Z" itemprop="datePublished">2019-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/19/summary_of_exam/">测评总结与反思</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天早上还复习了三个多小时…也没什么用…</p>
<p>今天的测评结果很糟糕。</p>
<p>当然，测评结果不好的最最主要的原因就是自己学艺不精了。今天测评老师问我有看什么书来学习吗，我只能很尴尬地说没有…都没想过要去看这方面的书来更好地学习，一直以来都是任务卡学会了做好了感觉就好了，任务卡和链接里上没有的，线下培训没讲过的，基本都不会，因为很多东西都不知道，更说不上主动去学去了解了。而且其实任务卡上的东西，也没有说学的十分透彻，就是知道了啊这个是这个，那个是那个，它们的区别和联系，心里面好像都知道点，要说出来又不能说得清清楚楚有底气（就是没学好…）</p>
<p>还有就是今天CSS布局那道题，测评老师说我“没有章法”，这个确实，我写css就是边写边试，一般是心里有个想法，就开始一点一点试，试试改改就看起来是想要的样式了，有时候加的样式很多了，自己也不知道真正是哪几个样式互相配合有了这个效果。也是和上面一样，学习局限于任务卡，只要能达到作业要的效果就好，对于一些现在，怎么说，“商业”或者“专业”的网页布局是用什么方法实现的，和一些对于某一种布局的“专业称呼”——专有名词，都不太清楚。像今天那道布局题，要我自己写就会<code>float</code>加<code>margin</code>了，可能就只是从静态布局上看起来像那么回事了。对于CSS的学习，我想除了看书外，也可以多看看人家商业的、成熟的网站，在控制台，看看人家都是怎么实现的，怎么写的。</p>
<p>今天的测评，就主要暴露了两点吧，一个是“猪八戒吃人参果”，学的不细，还有就是太依赖于以及只着眼于任务卡，学的不全面不系统，今天测评老师也推荐了<strong>相关的书</strong>。其实我也有点话想说，培训也快三个月了，真的还挺累的，有每天培训地任务作业，有学校的事情，有生活上的事情，感觉好像每天，也不管做得任务多不多吧，都过得很紧张233，但是话又说回来，像这样花了时间精力，却只学了个大概的话，也是对自己时间的浪费。<br>所以说，还是加油8~，生活一直很辛苦的说233┐(￣ヮ￣)┌<br><img src="http://ww1.sinaimg.cn/large/a85d55ddly1fzcbv5yvb2j208s07igly.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/19/summary_of_exam/" data-id="cjrc5773i0005qgowd6pney2p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-single_responsibility_principle" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/16/single_responsibility_principle/" class="article-date">
  <time datetime="2019-01-16T09:18:16.106Z" itemprop="datePublished">2019-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/16/single_responsibility_principle/">单一职责原则</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>单一职责原则</strong>（SRP：Single responsibility principle）又称单一功能原则，面向对象五个基本原则（SOLID）之一。它规定<strong>一个类应该只有一个发生变化的原因</strong>。</p>
<p>所谓<strong>职责</strong>是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。</p>
<p>单一职责原则的重要性在于，如果一个类拥有多于一个的职责，则这些职责就耦合到在了一起，那么就会有多于一个原因来导致这个类的变化。对于某一职责的更改可能会损害类满足其他耦合职责的能力。这样<strong>职责的耦合会导致设计的脆弱</strong>，以至于当职责发生更改时产生无法预期的破坏。</p>
<p>举一个网上的例子，<br><img src="https://images0.cnblogs.com/i/175043/201406/101818121707390.png" alt=""></p>
<p>上图图中的设计，类图中显示 <code>Rectangle</code> 类包含两个方法，一个方法（<code>Draw</code>）负责在显示屏幕上绘制矩形，另一个方法（<code>Area</code>）负责计算矩形图形面积。</p>
<p>有两个不同的应用程序均使用了 <code>Rectangle</code> 类。一个应用为计算几何程序(<code>ComputationalGeometryApplication</code>)，它使用了 <code>Rectangle</code> 中的数学几何模型，但不会在显示屏幕上绘制矩形。另一个应用是一个图形界面程序（<code>GUI</code>），它可能会做一些计算几何方面的工作，但主要功能是在屏幕上绘制矩形。</p>
<p>这个设计侵犯了 SRP 原则。<code>Rectangle</code> 类包含了两个职责。第一个职责是提供矩形几何计算的数学模型，第二个职责是在 <code>GUI</code> 上渲染矩形。</p>
<p>这会导致诸多难以解决的问题：</p>
<p>首先，我们必须在计算几何应用中包含对 <code>GUI</code> 库的引用。这导致应用程序无谓的<strong>消耗</strong>了链接时间、编译时间、内存空间和存储空间等。</p>
<p>再者，如果因为某些原因对 <code>GraphicalApplication</code> 的一个更改导致 <code>Rectangle</code> 类也相应做了更改，这将强制我们对 <code>ComputationalGeometryApplication</code> 进行重新编译、重新测试和重新部署等。如果我们忘了做这些事情，那么应用程序可能以<strong>无法预期</strong>的方式而<strong>崩溃</strong>。</p>
<p>所以，应当把这两个职责完全隔离到不同的类当中去。<br><img src="https://images0.cnblogs.com/i/175043/201406/101820070453862.png" alt=""><br>将 <code>Rectangle</code> 中关于几何计算的职责移到了 <code>GeometricRectangle</code> 类中，而 <code>Rectangle</code> 类中仅保留矩形渲染职责。这样，如果我们再对 <code>Rectangle</code> 中渲染职责进行更改时将不会再影响到 <code>ComputationalGeometryApplication</code> 了。</p>
<p>所以，为了代码的可读性和可维护性，以及为了解决资源，我们应当遵守单一职责原则。在之前js的学习中，有时候有的方法很简单，代码只有一行，我会把两个功能写进一个方法，这样就很不好，一个方法只做一件事，不论这件事有多简单，这应该成为一种习惯。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/16/single_responsibility_principle/" data-id="cjrc5773b0004qgow8gko4i8h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-notes_of_java_foundation" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/16/notes_of_java_foundation/" class="article-date">
  <time datetime="2019-01-16T08:03:10.190Z" itemprop="datePublished">2019-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/16/notes_of_java_foundation/">Java基础语法笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Java的主要特性"><a href="#Java的主要特性" class="headerlink" title="Java的主要特性"></a>Java的主要特性</h2><ol>
<li><strong>简单</strong>： Java语言是从C++ 发展起来的， 与此同时，Java取消了C++中复杂且难以掌握的东西，比如指针的，让Java的学习变得相对容易。</li>
<li><strong>面向对象</strong>： Java是一门面向对象设计的高级语言，面向对象设计是这门语言的灵魂。</li>
<li><strong>跨平台</strong>： Java语言编写的应用程序，不受平台限制，可以由一种平台迁移到另一种平台。</li>
<li><strong>解释性</strong>： Java是一门需要被编译解释的语言，使用java语言编写的源码被转化为字节码，字节码只有被Java虚拟机解释成机器码才能被计算机执行。</li>
<li><strong>健壮性</strong>： java提供了许多机制防止运行时出现严重错误，如编译时类型检查、异常处理。</li>
<li><strong>多线程</strong>： Java是一门高性能的语言，其中重要的原因是多线程的引入，能够极大的提升CPU的利用率</li>
</ol>
<p><a href="https://song-nan17.github.io/2019/01/14/jvm_jre_jdk/" target="_blank" rel="noopener">JVM, JRE,JDK的区别和联系</a></p>
<h2 id="变量，常量及方法"><a href="#变量，常量及方法" class="headerlink" title="变量，常量及方法"></a>变量，常量及方法</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>程序之中用来定义名称的都叫标识符，<strong>类名</strong>，<strong>变量名</strong>，<strong>方法名</strong>都被称为标识符。</p>
<h3 id="Java标识符命名规范："><a href="#Java标识符命名规范：" class="headerlink" title="Java标识符命名规范："></a>Java标识符命名规范：</h3><ul>
<li>所有的标识符都应该以<strong>字母</strong>(A-Z/a-z),<strong>美元符</strong>($)或者<strong>下划线</strong>(_)开始；</li>
<li>字符之后可以是字母(A-Z/a-z),美元符($),下划线(_)或数字的任何字符组合；</li>
<li>关键字不能用作标识符；</li>
<li>标识符是<strong>大小写敏感</strong>的。<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3>Java语言中的关键字：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">int</th>
<th style="text-align:center">short</th>
<th style="text-align:center">try</th>
<th style="text-align:center">char</th>
<th style="text-align:center">final</th>
<th style="text-align:center">interface</th>
<th style="text-align:center">static</th>
<th style="text-align:center">void</th>
<th style="text-align:center">float</th>
<th style="text-align:center">native</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">abstract</td>
<td style="text-align:center">continue</td>
<td style="text-align:center">for</td>
<td style="text-align:center">new</td>
<td style="text-align:center">switch</td>
<td style="text-align:center">assert</td>
<td style="text-align:center">default</td>
<td style="text-align:center">goto</td>
<td style="text-align:center">super</td>
<td style="text-align:center">while</td>
</tr>
<tr>
<td style="text-align:center">package</td>
<td style="text-align:center">synchronized</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">do</td>
<td style="text-align:center">if</td>
<td style="text-align:center">private</td>
<td style="text-align:center">this</td>
<td style="text-align:center">break</td>
<td style="text-align:center">class</td>
<td style="text-align:center">finally</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">implements</td>
<td style="text-align:center">protected</td>
<td style="text-align:center">throw</td>
<td style="text-align:center">byte</td>
<td style="text-align:center">else</td>
<td style="text-align:center">import</td>
<td style="text-align:center">public</td>
<td style="text-align:center">long</td>
<td style="text-align:center">stricfp</td>
</tr>
<tr>
<td style="text-align:center">throws</td>
<td style="text-align:center">case</td>
<td style="text-align:center">enum</td>
<td style="text-align:center">instanceof</td>
<td style="text-align:center">return</td>
<td style="text-align:center">transient</td>
<td style="text-align:center">catch</td>
<td style="text-align:center">extends</td>
<td style="text-align:center">volatile</td>
<td style="text-align:center">const</td>
</tr>
</tbody>
</table>
<p><strong>另外</strong>：</p>
<ul>
<li><code>const</code>和<code>go</code>关键字虽然已经不在使用，但是他们还是被保留下来了。</li>
<li><code>true</code>，<code>false</code>，<code>null</code> 虽然被很多人误认为是关键字，但是实际上他们只是字面而已。<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3>Java语言定义了以下三种变量：</li>
<li><strong>局部变量</strong>：没有特殊的关键字将变量标记为局部变量，这完全取决于声明变量的位置——它<strong>位于方法的两个大括号之间</strong>。因此，局部变量只对声明它们的方法可见，对于类的其他部分来说它们是不可见的。</li>
<li><strong>类变量</strong>(静态域): 类变量是使用<code>static</code>关键字修饰的域。这告诉编译器无论这个类有多少个实例，这个变量<strong>只有一个副本</strong>。</li>
<li><strong>成员变量</strong>(非静态域)：从技术层面来说，对象将它们各自的状态存在“非静态域”中，也就是没有使用static关键字修饰的域。非静态域也被称为实例变量，因为对于类的每个实例（换句话说，就是每个对象）来说，它们的值都是独立的。<h4 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h4></li>
<li>变量属于标识符，因此必须符合标识符的命名规范。</li>
<li>变量的命名必须是有意义的，做到名如其意。</li>
<li>变量名最好用英文名词，禁止使用拼音。</li>
<li>变量名需要用小驼峰命名法<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3></li>
<li>通常用<code>final</code>关键字来声明</li>
<li>常量使用注意事项：<ul>
<li>常量在定义的时候，就需要对常量进行初始化。</li>
<li>常量一旦初始化之后，就不能再次对其赋值。</li>
<li><code>final</code>关键字不仅可以用来修饰基本数据类型的常量，还可以用来修饰对象的引用或者方法。</li>
<li><code>final</code>关键字与<code>static</code>关键字同时使用。<h4 id="常量命名规则"><a href="#常量命名规则" class="headerlink" title="常量命名规则"></a>常量命名规则</h4></li>
</ul>
</li>
<li>常量属于标识符，因此也必须要符合标识符的命名规范。</li>
<li>常量的命名必须要有具体的含义，做到名如其意。</li>
<li>常量名最好用英文名词， 禁止使用中文拼音。</li>
<li><p>常量名需要全部大写，相邻单词之间用下划线(_)隔开。如 final int PI = 3.1415927;等</p>
<h3 id="方法（函数）"><a href="#方法（函数）" class="headerlink" title="方法（函数）"></a>方法（函数）</h3><p>方法者，就是具有独立业务逻辑的代码集合</p>
<h4 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名) &#123;</span><br><span class="line">    方法体</span><br><span class="line">    return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰符：可选，告诉编译器如何调用该方法。定义了该方法的访问类型。</p>
</li>
<li>返回值类型： 就是<code>return</code>之后的返回值的类型，有些方法可能没有返回值，用关键字<code>void</code>来表示。</li>
<li>方法名：就是方法的名字，必须符合一定的命名规范。</li>
<li>参数：由参数类型和参数名称组成。参数名是一个变量，用于接收调用方法时传入的数据。</li>
<li>方法体：被封装的独立代码块，是方法的核心部分，处理重要的业务逻辑。</li>
</ul>
<p>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public int getMaxValue(int val1, int val2) &#123;</span><br><span class="line">    int result = val1 &gt;= val2 ? val1 : val2;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：方法体遵循单一职责原则，即每个方法就仅仅做一件事情，这样可以增加可读性和可维护性。</p>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>与js中相同，调用方法名并传入相应的参数即可。例如上面方法调用为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int maxValue = getMaxValue(2, 3);</span><br></pre></td></tr></table></figure></p>
<h4 id="方法的命名规则："><a href="#方法的命名规则：" class="headerlink" title="方法的命名规则："></a>方法的命名规则：</h4><ul>
<li>方法名属于标识符，因此也必须要符合标识符的命名规范。</li>
<li>方法的命名必须要有具体的含义，做到名如其意。</li>
<li>方法名最好用英文动词，表示一个动作，禁止使用中文拼音。</li>
<li>方法名需要用小驼峰命名法，首字母小写，后面的单词需首字母大写，来用区分相邻单词。</li>
</ul>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>
<h3 id="byte："><a href="#byte：" class="headerlink" title="byte："></a>byte：</h3><ul>
<li><code>byte</code> 数据类型是<code>8</code>位、有符号的，以二进制补码表示的整数；</li>
<li>最小值是 <code>-128</code>（<code>-2^7</code>）；</li>
<li>最大值是 <code>127</code>（<code>2^7-1</code>）；</li>
<li>默认值是 <code>0</code>；</li>
<li><code>byte</code> 类型用在大型数组中节约空间，主要代替整数，因为 <code>byte</code> 变量占用的空间只有 int 类型的四分之一；</li>
<li>例子：<code>byte a = 100，byte b = -50</code>。<h3 id="short："><a href="#short：" class="headerlink" title="short："></a>short：</h3></li>
<li><code>short</code> 数据类型是 <code>16</code> 位、有符号的以二进制补码表示的整数</li>
<li>最小值是 <code>-32768</code>（<code>-2^15</code>）；</li>
<li>最大值是 <code>32767</code>（<code>2^15 - 1</code>）；</li>
<li><code>Short</code> 数据类型也可以像 <code>byte</code> 那样节省空间。一个<code>short</code>变量是<code>int</code>型变量所占空间的二分之一；</li>
<li>默认值是<code>0</code>；</li>
<li>例子：<code>short s = 1000，short r = -20000</code>。<h3 id="int："><a href="#int：" class="headerlink" title="int："></a>int：</h3></li>
<li><code>int</code> 数据类型是<code>32</code>位、有符号的以二进制补码表示的整数；</li>
<li>最小值是 <code>-2,147,483,648</code>（<code>-2^31</code>）；</li>
<li>最大值是 <code>2,147,483,647</code>（<code>2^31 - 1</code>）；</li>
<li>一般地整型变量默认为 <code>int</code> 类型；</li>
<li>默认值是 <code>0</code> ；</li>
<li>例子：<code>int a = 100000, int b = -200000</code>。<h3 id="long："><a href="#long：" class="headerlink" title="long："></a>long：</h3></li>
<li><code>long</code> 数据类型是 <code>64</code> 位、有符号的以二进制补码表示的整数；</li>
<li>最小值是 <code>-9,223,372,036,854,775,808</code>（<code>-2^63</code>）；</li>
<li>最大值是 <code>9,223,372,036,854,775,807</code>（<code>2^63 -1</code>）；</li>
<li>这种类型主要使用在需要比较大整数的系统上；</li>
<li>默认值是 <code>0L</code>；</li>
<li>整数字面量默认都为 <code>int</code> 类型，所以在定义的 <code>long</code> 型数据后面加 <code>L</code>或 <code>l</code>。</li>
<li>例子： <code>long a = 100000L，Long b = -200000L</code>。</li>
<li>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。<h3 id="float："><a href="#float：" class="headerlink" title="float："></a>float：</h3></li>
<li><code>float</code> 数据类型是单精度、<code>32</code>位、符合IEEE 754标准的浮点数；</li>
<li><code>float</code> 在储存大型浮点数组的时候可节省内存空间；</li>
<li>默认值是 <code>0.0f</code>；</li>
<li>浮点数字面量默认都为 <code>double</code> 类型，所以在定义的 <code>float</code> 型数据后面加<code>F</code> 或 <code>f</code>；</li>
<li><code>double</code> 类型可不写后缀，但在小数计算中一定要写 <code>D</code> 或 <code>X.X</code> </li>
<li>浮点数不能用来表示精确的值，如货币；</li>
<li>例子：<code>float f1 = 234.5f</code>。<h3 id="double："><a href="#double：" class="headerlink" title="double："></a>double：</h3></li>
<li><code>double</code> 数据类型是双精度、<code>64</code> 位、符合IEEE 754标准的浮点数；</li>
<li>浮点数的默认类型为<code>double</code>类型；</li>
<li><code>double</code>类型同样不能表示精确的值，如货币；</li>
<li>默认值是 <code>0.0d</code>；</li>
<li>例子：<code>double d1 = 123.4</code>。<h3 id="boolean："><a href="#boolean：" class="headerlink" title="boolean："></a>boolean：</h3></li>
<li><code>boolean</code>数据类型表示一位的信息；</li>
<li>只有两个取值：<code>true</code> 和 <code>false</code>；</li>
<li>这种类型只作为一种标志来记录 <code>true</code>/<code>false</code> 情况；</li>
<li>默认值是 <code>false</code>；</li>
<li>例子：<code>boolean one = true</code>。<h3 id="char："><a href="#char：" class="headerlink" title="char："></a>char：</h3></li>
<li><code>char</code>类型是一个单一的 <code>16</code> 位 <code>Unicode</code> 字符；</li>
<li>最小值是 <code>\u0000</code>（即为<code>0</code>）；</li>
<li>最大值是 <code>\uffff</code>（即为<code>65,535</code>）；</li>
<li><code>char</code> 数据类型可以储存任何字符；</li>
<li>例子：<code>char letter = &#39;A&#39;;</code>。</li>
</ul>
<p>实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。</p>
<h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</p>
<p>转换从低级到高级。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">低  ------------------------------------&gt;  高</span><br><span class="line"></span><br><span class="line">byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double</span><br></pre></td></tr></table></figure></p>
<p>数据类型转换必须满足如下规则：</p>
<ol>
<li><p>不能对boolean类型进行类型转换。</p>
</li>
<li><p>不能把对象类型转换成不相关类的对象。</p>
</li>
<li><p>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p>
</li>
<li><p>转换过程中可能导致溢出或损失精度，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i =128;   </span><br><span class="line">byte b = (byte)i;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p>
<ol start="5">
<li>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(int)23.7 == 23;        </span><br><span class="line">(int)-45.89f == -45</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>必须满足<strong>转换前的数据类型的位数要低于转换后的数据类型</strong>，例如: <code>short</code>数据类型的位数为16位，就可以自动转换位数为32的<code>int</code>类型，同样<code>float</code>数据类型的位数为<code>32</code>，可以自动转换为64位的<code>double</code>类型。</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ol>
<li><p>条件是转换的数据类型必须是兼容的。</p>
</li>
<li><p>格式：<code>(type)value type</code>是要强制类型转换后的数据类型</p>
</li>
</ol>
<p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class QiangZhiZhuanHuan&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int i1 = 123;</span><br><span class="line">        byte b = (byte)i1;//强制类型转换为byte</span><br><span class="line">        System.out.println(&quot;int强制类型转换为byte后的值等于&quot;+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int强制类型转换为byte后的值等于123</span><br></pre></td></tr></table></figure></p>
<h3 id="隐含强制类型转换"><a href="#隐含强制类型转换" class="headerlink" title="隐含强制类型转换"></a>隐含强制类型转换</h3><ol>
<li><p>整数的默认类型是 <code>int</code>。</p>
</li>
<li><p>浮点型不存在这种情况，因为在定义 <code>float</code> 类型时必须在数字后面跟上 <code>F</code> 或者 <code>f</code>。</p>
</li>
</ol>
<h2 id="java运算符"><a href="#java运算符" class="headerlink" title="java运算符"></a>java运算符</h2><p><a href="http://www.runoob.com/java/java-operators.html" target="_blank" rel="noopener">java运算符</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/16/notes_of_java_foundation/" data-id="cjrc57786000iqgowghyaqmg6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-IntelliJ-IDEA-Tutorial" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/15/IntelliJ-IDEA-Tutorial/" class="article-date">
  <time datetime="2019-01-15T13:14:28.609Z" itemprop="datePublished">2019-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/15/IntelliJ-IDEA-Tutorial/">初级IntelliJ IDEA使用总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于IntelliJ IDEA的使用方法，我主要是学习了<a href="https://blog.csdn.net/jiangyu1013/article/details/78780261" target="_blank" rel="noopener">java初学者教程</a>和<a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial" target="_blank" rel="noopener">https://github.com/judasn/IntelliJ-IDEA-Tutorial</a>两篇教程。</p>
<p>第二篇教程内容非常丰富，教程中有将IntelliJ IDEA和其他IDE对比，特别是和Eclipse.因为我之前并没有使用过Eclipse,也没有java项目开发经验，很多内容看起来头大…所以只学习了教程中的基础设置、快捷键,和IntelliJ IDEA的特别之处。</p>
<h2 id="开始一个小项目"><a href="#开始一个小项目" class="headerlink" title="开始一个小项目"></a>开始一个小项目</h2><p>启动IDEA后点击<code>Create New Projec</code>新建一个java项目<br><img src="http://ww1.sinaimg.cn/large/a85d55ddly1fz8dv0wyb5j20k00jzt9g.jpg" alt=""></p>
<p>左列默认新建java项目，右侧<code>new</code>配置JDK主目录。点击<code>next</code>设置项目名称和项目地址。</p>
<p>新建的项目目录如下：<br><img src="http://ww1.sinaimg.cn/large/a85d55ddly1fz8e73moagj20pl0e73z6.jpg" alt=""></p>
<p>新建了一个名为<code>HelloWorld</code>的项目。基本上所有的IntelliJ IDEA使用教程都会提到，在 IntelliJ IDEA 中 Project 是最顶级的级别，次级别是 Module。一个 Project 可以有多个 Module。而像上图则是只有一个Module的项目，所以Project 目录和 Module 目录是同一个，名为<code>HelloWorld</code>,而<code>src</code>实际上是Module下的目录。<code>.idea</code>和<code>HelloWorld.iml</code>是IDEA帮助我们建立的辅助文件夹和文件。<code>External Libraries</code>是引入的类库，目前只有JDK。<br>选中<code>src</code>目录，右键-&gt;<code>new</code>即可在<code>src</code>目录下新建不同类型的文件，如<code>java class</code>。</p>
<h2 id="IntelliJ-IDEA-编译和运行"><a href="#IntelliJ-IDEA-编译和运行" class="headerlink" title="IntelliJ IDEA 编译和运行"></a>IntelliJ IDEA 编译和运行</h2><p>在 IntelliJ IDEA 里，编译方式一共有三种：</p>
<ul>
<li><code>Compile</code>：对选定的目标（Java 类文件），进行强制性编译，不管目标是否是被修改过。注：2018版操作为<code>Recompile</code>。</li>
<li><code>Rebuild</code>：对选定的目标（Project），进行强制性编译，不管目标是否是被修改过，由于<code>Rebuild</code>的目标只有 Project，所以 <code>Rebuild</code> 每次花的时间会比较长。</li>
<li><code>Make</code>：使用最多的编译操作。对选定的目标（Project 或 Module）进行编译，但只编译有修改过的文件，没有修改过的文件不会编译，这样平时开发大型项目才不会浪费时间在编译过程中。注：2018版操作为<code>Build</code>。</li>
</ul>
<p>在菜单<code>Build</code>栏下即找到到三种编译的操作。</p>
<p>而在代码编辑区空白处右键或菜单栏<code>Run</code>都可以看到<code>Run</code>方法，运行代码。</p>
<h2 id="字体修改"><a href="#字体修改" class="headerlink" title="字体修改"></a>字体修改</h2><p>为了尽可能避免中文显示乱码和使界面更美观，可以修改字体。注意，我们应选择包含中文的字体。</p>
<ul>
<li><p>主题字体修改<br><img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-b-font-setting-1.jpg" alt=""></p>
</li>
<li><p>代码编辑字体修改<br><img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-b-font-setting-2.jpg" alt=""></p>
</li>
<li><p>控制台输出字体修改<br><img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-b-font-setting-3.jpg" alt=""></p>
</li>
</ul>
<h2 id="IntelliJ-IDEA快捷键"><a href="#IntelliJ-IDEA快捷键" class="headerlink" title="IntelliJ IDEA快捷键"></a>IntelliJ IDEA快捷键</h2><p>首先最好是去掉一些输入法，如搜狗输入法的快捷键。</p>
<p>IntelliJ IDEA快捷键：</p>
<h3 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ctrl</code> + <code>F</code></td>
<td>在当前文件进行文本查找 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>R</code></td>
<td>在当前文件进行文本替换 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Z</code></td>
<td>撤销 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Y</code></td>
<td>删除光标所在行 或 删除选中的行 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>X</code></td>
<td>剪切光标所在行 或 剪切选择内容</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>C</code></td>
<td>复制光标所在行 或 复制选择内容</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>D</code></td>
<td>复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>W</code></td>
<td>递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>E</code></td>
<td>显示最近打开的文件记录列表 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>N</code></td>
<td>根据输入的 类名 查找类文件 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>G</code></td>
<td>在当前文件跳转到指定行处</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>J</code></td>
<td>插入自定义动态代码模板 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>P</code></td>
<td>方法参数提示显示 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Q</code></td>
<td>光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>U</code></td>
<td>前往当前光标所在的方法的父类的方法 / 接口定义 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>B</code></td>
<td>进入光标所在的方法/变量的接口或是定义处，等效于 <code>Ctrl</code> + <code>左键单击</code> <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>K</code></td>
<td>版本控制提交项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>T</code></td>
<td>版本控制更新项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>H</code></td>
<td>显示当前类的层次结构</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>O</code></td>
<td>选择可重写的方法</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>I</code></td>
<td>选择可继承的方法</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>+</code></td>
<td>展开代码</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>-</code></td>
<td>折叠代码</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>/</code></td>
<td>注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>[</code></td>
<td>移动光标到当前所在代码的花括号开始位置</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>]</code></td>
<td>移动光标到当前所在代码的花括号结束位置</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>F1</code></td>
<td>在光标所在的错误代码处显示错误信息 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>F3</code></td>
<td>调转到所选中的词的下一个引用位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>F4</code></td>
<td>关闭当前编辑文件</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>F8</code></td>
<td>在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>F9</code></td>
<td>执行 Make Project 操作</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>F11</code></td>
<td>选中文件 / 文件夹，使用助记符设定 / 取消书签 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>F12</code></td>
<td>弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Tab</code></td>
<td>编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>End</code></td>
<td>跳到文件尾</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Home</code></td>
<td>跳到文件头</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Space</code></td>
<td>基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 <code>Ctrl</code> + <code>逗号</code> <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Delete</code></td>
<td>删除光标后面的单词或是中文句 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>BackSpace</code></td>
<td>删除光标前面的单词或是中文句 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>1,2,3...9</code></td>
<td>定位到对应数值的书签位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>左键单击</code></td>
<td>在打开的文件标题上，弹出该文件路径 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>光标定位</code></td>
<td>按 Ctrl 不要松开，会显示光标所在的类信息摘要</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>左方向键</code></td>
<td>光标跳转到当前单词 / 中文句的左侧开头位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>右方向键</code></td>
<td>光标跳转到当前单词 / 中文句的右侧开头位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>前方向键</code></td>
<td>等效于鼠标滚轮向前效果 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>后方向键</code></td>
<td>等效于鼠标滚轮向后效果 <code>（必备）</code></td>
</tr>
</tbody>
</table>
<h3 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Alt</code> + <code>反引号</code></td>
<td>显示版本控制常用操作菜单弹出层 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>Q</code></td>
<td>弹出一个提示，显示当前类的声明 / 上下文信息</td>
</tr>
<tr>
<td><code>Alt</code> + <code>F1</code></td>
<td>显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>F2</code></td>
<td>对于前面页面，显示各类浏览器打开目标选择弹出层</td>
</tr>
<tr>
<td><code>Alt</code> + <code>F3</code></td>
<td>选中文本，逐个往下查找相同文本，并高亮显示</td>
</tr>
<tr>
<td><code>Alt</code> + <code>F7</code></td>
<td>查找光标所在的方法 / 变量 / 类被调用的地方</td>
</tr>
<tr>
<td><code>Alt</code> + <code>F8</code></td>
<td>在 <code>Debug</code> 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td>
</tr>
<tr>
<td><code>Alt</code> + <code>Home</code></td>
<td>定位 / 显示到当前文件的 <code>Navigation Bar</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>Enter</code></td>
<td>IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>Insert</code></td>
<td>代码自动生成，如生成对象的 <code>set</code> / <code>get</code> 方法，构造函数，<code>toString()</code> 等 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>左方向键</code></td>
<td>切换当前已打开的窗口中的子视图，比如<code>Debug</code>窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>右方向键</code></td>
<td>按切换当前已打开的窗口中的子视图，比如<code>Debug</code>窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>前方向键</code></td>
<td>当前光标跳转到当前文件的前一个方法名位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>后方向键</code></td>
<td>当前光标跳转到当前文件的后一个方法名位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>1,2,3...9</code></td>
<td>显示对应数值的选项卡，其中 <code>1</code> 是 Project 用得最多 <code>（必备）</code></td>
</tr>
</tbody>
</table>
<h3 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Shift</code> + <code>F1</code></td>
<td>如果有外部文档可以连接外部文档</td>
</tr>
<tr>
<td><code>Shift</code> + <code>F2</code></td>
<td>跳转到上一个高亮错误 或 警告位置</td>
</tr>
<tr>
<td><code>Shift</code> + <code>F3</code></td>
<td>在查找模式下，查找匹配上一个</td>
</tr>
<tr>
<td><code>Shift</code> + <code>F4</code></td>
<td>对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td>
</tr>
<tr>
<td><code>Shift</code> + <code>F6</code></td>
<td>对文件 / 文件夹 重命名</td>
</tr>
<tr>
<td><code>Shift</code> + <code>F7</code></td>
<td>在 <code>Debug</code> 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td>
</tr>
<tr>
<td><code>Shift</code> + <code>F8</code></td>
<td>在 <code>Debug</code> 模式下，跳出，表现出来的效果跟 <code>F9</code> 一样</td>
</tr>
<tr>
<td><code>Shift</code> + <code>F9</code></td>
<td>等效于点击工具栏的 <code>Debug</code> 按钮</td>
</tr>
<tr>
<td><code>Shift</code> + <code>F10</code></td>
<td>等效于点击工具栏的 <code>Run</code> 按钮</td>
</tr>
<tr>
<td><code>Shift</code> + <code>F11</code></td>
<td>弹出书签显示层 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Shift</code> + <code>Tab</code></td>
<td>取消缩进 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Shift</code> + <code>ESC</code></td>
<td>隐藏当前 或 最后一个激活的工具窗口</td>
</tr>
<tr>
<td><code>Shift</code> + <code>End</code></td>
<td>选中光标到当前行尾位置</td>
</tr>
<tr>
<td><code>Shift</code> + <code>Home</code></td>
<td>选中光标到当前行头位置</td>
</tr>
<tr>
<td><code>Shift</code> + <code>Enter</code></td>
<td>开始新一行。光标所在行下空出一行，光标定位到新行位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Shift</code> + <code>左键单击</code></td>
<td>在打开的文件名上按此快捷键，可以关闭当前打开文件 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Shift</code> + <code>滚轮前后滚动</code></td>
<td>当前文件的横向滚动轴滚动 <code>（必备）</code></td>
</tr>
</tbody>
</table>
<h3 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl + Alt"></a>Ctrl + Alt</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>L</code></td>
<td>格式化代码，可以对当前文件和整个包目录使用 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>O</code></td>
<td>优化导入的类，可以对当前文件和整个包目录使用 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>I</code></td>
<td>光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>T</code></td>
<td>对选中的代码弹出环绕选项弹出层 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>J</code></td>
<td>弹出模板选择窗口，将选定的代码加入动态模板中</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>H</code></td>
<td>调用层次</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>B</code></td>
<td>在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>C</code></td>
<td>重构-快速提取常量</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>F</code></td>
<td>重构-快速提取成员变量</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>V</code></td>
<td>重构-快速提取变量</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>Y</code></td>
<td>同步、刷新</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>S</code></td>
<td>打开 IntelliJ IDEA 系统设置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>F7</code></td>
<td>显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>F11</code></td>
<td>切换全屏模式</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>Enter</code></td>
<td>光标所在行上空出一行，光标定位到新行 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>Home</code></td>
<td>弹出跟当前文件有关联的文件弹出层</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>Space</code></td>
<td>类名自动完成</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>左方向键</code></td>
<td>退回到上一个操作的地方 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>右方向键</code></td>
<td>前进到上一个操作的地方 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>前方向键</code></td>
<td>在查找模式下，跳到上个查找的文件</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>后方向键</code></td>
<td>在查找模式下，跳到下个查找的文件</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>右括号（]）</code></td>
<td>在打开多个项目的情况下，切换下一个项目窗口</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>左括号（[）</code></td>
<td>在打开多个项目的情况下，切换上一个项目窗口</td>
</tr>
</tbody>
</table>
<h3 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a>Ctrl + Shift</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>F</code></td>
<td>根据输入内容查找整个项目 或 指定目录内文件 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>R</code></td>
<td>根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>J</code></td>
<td>自动将下一行合并到当前行末尾 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Z</code></td>
<td>取消撤销 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>W</code></td>
<td>递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>N</code></td>
<td>通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>U</code></td>
<td>对选中的代码进行大 / 小写轮流转换 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>T</code></td>
<td>对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>C</code></td>
<td>复制当前文件磁盘路径到剪贴板 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>V</code></td>
<td>弹出缓存的最近拷贝的内容管理器弹出层</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>E</code></td>
<td>显示最近修改的文件列表的弹出层</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>H</code></td>
<td>显示方法层次结构</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>B</code></td>
<td>跳转到类型声明处 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>I</code></td>
<td>快速查看光标所在的方法 或 类的定义</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>A</code></td>
<td>查找动作 / 设置</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>/</code></td>
<td>代码块注释 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>[</code></td>
<td>选中从光标所在位置到它的顶部中括号位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>]</code></td>
<td>选中从光标所在位置到它的底部中括号位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>+</code></td>
<td>展开所有代码 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>-</code></td>
<td>折叠所有代码 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>F7</code></td>
<td>高亮显示所有该选中文本，按Esc高亮消失 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>F8</code></td>
<td>在 <code>Debug</code> 模式下，指定断点进入条件</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>F9</code></td>
<td>编译选中的文件 / 包 / Module</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>F12</code></td>
<td>编辑器最大化 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Space</code></td>
<td>智能代码提示</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Enter</code></td>
<td>自动结束代码，行末自动添加分号 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Backspace</code></td>
<td>退回到上次修改的地方 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>1,2,3...9</code></td>
<td>快速添加指定数值的书签 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>左键单击</code></td>
<td>把光标放在某个类变量上，按此快捷键可以直接定位到该类中 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>左方向键</code></td>
<td>在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>右方向键</code></td>
<td>在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>前方向键</code></td>
<td>光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>后方向键</code></td>
<td>光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 <code>（必备）</code></td>
</tr>
</tbody>
</table>
<h3 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a>Alt + Shift</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>N</code></td>
<td>选择 / 添加 <code>task</code>  <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>F</code></td>
<td>显示添加到收藏夹弹出层 / 添加到收藏夹</td>
</tr>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>C</code></td>
<td>查看最近操作项目的变化情况列表</td>
</tr>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>I</code></td>
<td>查看项目当前文件</td>
</tr>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>F7</code></td>
<td>在 <code>Debug</code> 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td>
</tr>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>F9</code></td>
<td>弹出 <code>Debug</code> 的可选择菜单</td>
</tr>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>F10</code></td>
<td>弹出 <code>Run</code> 的可选择菜单</td>
</tr>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>左键双击</code></td>
<td>选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>前方向键</code></td>
<td>移动光标所在行向上移动 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>后方向键</code></td>
<td>移动光标所在行向下移动 <code>（必备）</code></td>
</tr>
</tbody>
</table>
<h3 id="Ctrl-Shift-Alt"><a href="#Ctrl-Shift-Alt" class="headerlink" title="Ctrl + Shift + Alt"></a>Ctrl + Shift + Alt</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Alt</code> + <code>V</code></td>
<td>无格式黏贴 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Alt</code> + <code>N</code></td>
<td>前往指定的变量 / 方法</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Alt</code> + <code>S</code></td>
<td>打开当前项目设置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Alt</code> + <code>C</code></td>
<td>复制参考信息</td>
</tr>
</tbody>
</table>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>F2</code></td>
<td>跳转到下一个高亮错误 或 警告位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>F3</code></td>
<td>在查找模式下，定位到下一个匹配处</td>
</tr>
<tr>
<td><code>F4</code></td>
<td>编辑源 <code>（必备）</code></td>
</tr>
<tr>
<td><code>F7</code></td>
<td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td>
</tr>
<tr>
<td><code>F8</code></td>
<td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td>
</tr>
<tr>
<td><code>F9</code></td>
<td>在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td>
</tr>
<tr>
<td><code>F11</code></td>
<td>添加书签 <code>（必备）</code></td>
</tr>
<tr>
<td><code>F12</code></td>
<td>回到前一个工具窗口 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Tab</code></td>
<td>缩进 <code>（必备）</code></td>
</tr>
<tr>
<td><code>ESC</code></td>
<td>从工具窗口进入代码文件窗口 <code>（必备）</code></td>
</tr>
<tr>
<td><code>连按两次Shift</code></td>
<td>弹出 <code>Search Everywhere</code> 弹出层</td>
</tr>
</tbody>
</table>
<h3 id="快捷键修改"><a href="#快捷键修改" class="headerlink" title="快捷键修改"></a>快捷键修改</h3><p><code>setting</code>-&gt;<code>keymap</code></p>
<p><img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/xxvii-a-keymap-setting-1.jpg" alt=""></p>
<ul>
<li>可以通过上图<code>1</code>所示的，通过输入快捷键描述内容；还可以上图标注 <code>2</code> 所示的，通过<strong>按</strong>指定快捷键的快捷键。</li>
<li>上图标注 <code>3</code> 所示，初安装的 IntelliJ IDEA 使用的是 Default 的快捷键模板，IntelliJ IDEA 默认的快捷键模板都是不可修改的。如果直接修改，当前这个位置 IntelliJ IDEA 会自动变成 Default Copy，教程中建议养成习惯，修改之前先点击 Copy，拷贝一套快捷键模板，然后输入自己的命名。</li>
</ul>
<p><img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/xxvii-a-keymap-setting-2.jpg" alt=""></p>
<ul>
<li>要修改某个快捷键，选中快捷键介绍内容，右键，就会弹出如上图标注 <code>1</code> 所示操作选择。</li>
<li>命令 <code>Add Keyboard Shortcut</code> 用来添加新纯键盘快捷键组合。</li>
<li>命令 <code>Add Mouse Shortcut</code> 用来添加新 键盘 + 鼠标 快捷键组合，比如设置 <code>Ctrl</code> + <code>左键单击</code> 这类快捷组合。其中在弹出的添加面板中 <code>Click Pad</code> 是用来监听当前鼠标是左键单击还是右键单击。 </li>
<li>命令 <code>Remove</code> 快捷键 移出当前操作命令已设置的快捷键组合。</li>
</ul>
<h2 id="常见文件类型的图标介绍"><a href="#常见文件类型的图标介绍" class="headerlink" title="常见文件类型的图标介绍"></a>常见文件类型的图标介绍</h2><h3 id="Java-类相关图标介绍"><a href="#Java-类相关图标介绍" class="headerlink" title="Java 类相关图标介绍"></a>Java 类相关图标介绍</h3><p><img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/xi-a-file-symbols-1.jpg" alt=""></p>
<ul>
<li><p>官网地址：<a href="http://www.jetbrains.com/idea/webhelp/symbols.html" target="_blank" rel="noopener">http://www.jetbrains.com/idea/webhelp/symbols.html</a></p>
</li>
<li><p><img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/xi-a-file-symbols-2.gif" alt=""><br><code>Source root</code>，可以理解为源目录，源码的作用就是用来专门放 <code>Java</code> 类文件，相对于编译出来的 <code>class</code> 文件而言，它就是源。我们一般默认名字叫 <code>src</code> 的目录就是源目录，但是其实并不是这样的，在 IntelliJ IDEA 中，即使叫 srcs 也是可以设置为 Source root，所以源目录跟目录命名是没有关系的，而是在于 IntelliJ IDEA 支持对任意目录进行设置为 Source 可以在文头的第二个教程中查找。</p>
</li>
<li><img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/xi-a-file-symbols-3.png" alt=""> <code>Java class located out of the source root</code>，如果 <code>Java</code> 类文件没有放在该目录或是该目录的子包下，那该 <code>Java</code> 类则无法编译，就会被表示成这个图标。<h3 id="各类文件类型图标介绍"><a href="#各类文件类型图标介绍" class="headerlink" title="各类文件类型图标介绍"></a>各类文件类型图标介绍</h3><img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/xi-b-file-symbols-1.jpg" alt=""></li>
<li>官网地址：<a href="http://www.jetbrains.com/idea/webhelp/file-types-recognized-by-intellij-idea.html" target="_blank" rel="noopener">http://www.jetbrains.com/idea/webhelp/file-types-recognized-by-intellij-idea.html</a></li>
<li>JavaScript 两种图标介绍<img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/xi-b-file-symbols-2.png" alt=""></li>
<li>如上图所示，对于压缩过的 JavaScript 文件，图标会有 <code>010</code>图案。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/15/IntelliJ-IDEA-Tutorial/" data-id="cjrc577b7000mqgowlz4doc3e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jvm_jre_jdk" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/14/jvm_jre_jdk/" class="article-date">
  <time datetime="2019-01-14T14:29:34.794Z" itemprop="datePublished">2019-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/14/jvm_jre_jdk/">JVM, JRE, JDK 的区别和联系</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM是JavaVirtual Machine（<strong>Java虚拟机</strong>）的缩写，它是整个java实现跨平台的最核心的部分，不是 Java 能够跨平台，而是它的 jvm 能够跨平台。</p>
<p>所有的java程序会首先被编译为<code>.class</code>的类文件，这种类文件可以在虚拟机上执行，也就是说<code>.class</code>并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</p>
<p>JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p>
<p>JVM也有自己的指令集，并且在运行时操作不同的内存区域。 JVM的主要工作是解释自己的指令集（即字节码）到CPU的指令集或对应的系统调用，保护用户免被恶意程序骚扰。 JVM对上层的Java源文件是不关心的，它关注的只是由源文件生成的类文件（<code>.class</code>文件）。</p>
<h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h2><p>JRE是java runtime environment（<strong>java运行环境</strong>）的缩写。</p>
<p>光有JVM还不能让<code>.class</code>文件执行，因为在解释<code>.class</code>的时候JVM需要调用解释所需要的类库<code>lib</code>。在JDK的安装目录里可以找到<code>jre</code>目录，里面有两个文件夹<code>bin</code>和<code>lib</code>,在这里可以认为<code>bin</code>里的就是<code>jvm</code>，<code>lib</code>中则是<code>jvm</code>工作所需要的类库，而<code>jvm</code>和<code>lib</code>和起来就称为<code>jre</code>。</p>
<p>JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），是提供给用户来直接使用运行编译后的java程序的。</p>
<h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>JDK是java development kit（<strong>java开发工具包</strong>）的缩写,是Sun Microsystems针对Java开发员的产品。</p>
<p>在JDK安装目录下面有六个文件夹、一个<code>src</code>类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：<code>bin</code>、<code>include</code>、<code>lib</code>、<code>jre</code>。</p>
<ul>
<li><p><code>bin</code>:最主要的是编译器(javac.exe)</p>
</li>
<li><p><code>include</code>:java和JVM交互用的头文件</p>
</li>
<li><p><code>lib</code>：类库 （java开发需要的类库）    </p>
</li>
<li><p><code>jre</code>:java运行环境 </p>
</li>
</ul>
<p>(eclipse、idea等其他IDE(集成开发环境)有自己的编译器而不是用JDK bin目录中自带的，所以在安装时只要求选jre路径)</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由安装目录可以看出这样一个关系：<strong>JDK包含JRE，而JRE包含JVM</strong>。jdk是用来java程序开发的，而jre是只能运行<code>class</code>而没有编译的功能，jre是java能够跨平台运行的核心。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/14/jvm_jre_jdk/" data-id="cjrc5771q0001qgow9eqm5m8q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-summary_week5_2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/13/summary_week5_2/" class="article-date">
  <time datetime="2019-01-13T13:21:18.266Z" itemprop="datePublished">2019-01-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/13/summary_week5_2/">总结—第一阶段第五周</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>上周忘记写总结了…这两周就是在做<code>todo-list</code>和思沃影院。做这两个作业时，回顾、应用了很多以前学习的知识，对以前学习的内容有了更好的掌握。<code>HTML</code>和<code>CSS</code>是必不可少的，不用说。做<code>todo-list</code>是用了很多的事件监听和事件代理，以及<code>DOM</code>方法和属性，<code>localStorage</code>方法。完成<code>todo-list</code>后，做思沃影院更好做了。如显示推荐电影和分类电影就采用了<code>todod-list</code>里显示<code>todos</code>的方法，而随机推荐不重复的高分电影和轮播图则是想到了之前打地鼠作业里控制地鼠随机连续出动的方法完成的。可见，还是要多练，可能刚学的时候没有很深的感受，通过练习后就能理解的更好也掌握的更好。</p>
<p>做思沃影院时也学到了一些新方法，如<code>window.location = url</code>跳转指定链接，跳转时可在链接后添加参数，如：<code>window.location = &quot;movie-details.html?id=$123&quot;</code>,还可以用<code>window.location.href</code>获得当前页面的链接。如果要向<code>url</code>添加的参数为中文，则应先将中文编码，再添加至<code>url</code>,要获取该参数，获取后再解码即可。如，使用<code>encodeURI()</code>编码中文，使用<code>decodeURI()</code>解码。</p>
<h2 id="三圈"><a href="#三圈" class="headerlink" title="三圈"></a>三圈</h2><p>上周有元旦假期，这周相比上周当然是处于学习圈了。但是这周不是简单的代码练习，而是有两个小项目，其中一个还要合作完成，虽然比较忙，但是完成之后看着这两个小项目，还是很开心的，小有成就感233.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/13/summary_week5_2/" data-id="cjrc57765000dqgowgmp126do" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-summary_week3_2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/29/summary_week3_2/" class="article-date">
  <time datetime="2018-12-29T14:10:59.401Z" itemprop="datePublished">2018-12-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/29/summary_week3_2/">总结—JS进阶第三周</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习和反思"><a href="#学习和反思" class="headerlink" title="学习和反思"></a>学习和反思</h2><p>这周前半周主要在做ES6的运算合集和复习前面的知识。运算合集这是之前做过的，没有遇到什么问题。复习方面，周五的小问题环节，我发现我真是严格按照考察表复习的…有些东西考察表上虽然没写，但是是最基本的，还是要好好复习啊..譬如引入CSS的方法，我只是记住了有三种，以及它们大概的内容…在后面的复习中对于一些最基本的内容，比如定义什么的，还是要记清楚。<br>后两天就是在做打印成绩单任务卡，也是了解感受了测试驱动开发，任务卡还没完成，做得过程太粗心了，花了些多余的时间。对于打印提示的main()的测试代码，还没想好怎么写。</p>
<h2 id="三圈"><a href="#三圈" class="headerlink" title="三圈"></a>三圈</h2><p>时间过得好快，也感觉不出来是什么圈…相比上周的舒适圈的话，这周算处于学习圈吧，因为这周的打印成绩单还挺难的，上周的任务卡就比较简单了，自己一个人就做得来。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/29/summary_week3_2/" data-id="cjrc5775y000cqgowa3q6vf27" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-summary_week2_2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/23/summary_week2_2/" class="article-date">
  <time datetime="2018-12-23T12:58:00.509Z" itemprop="datePublished">2018-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/23/summary_week2_2/">总结—JS进阶第二周</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>这周的新内容是ES6和面向对象。</p>
<p>ES6新特性中中目前在写代码中使用较多的是<code>let</code>,<code>const</code>，模板字符串和箭头函数，其他内容处于了解阶段。</p>
<p>面向对象任务卡了解了什么是面向对象，其最主要的特质是<strong>封装</strong>，<strong>继承</strong>，<strong>多态</strong>，以及面向对象编程的优点。加下线下学习的内容，了解了想要创建一个指定类型的对象时可以用创建函数法和对象原型，以及两者兼有的方法，ES6还提供了更简洁的方法，类<code>class</code>。</p>
<h2 id="三圈"><a href="#三圈" class="headerlink" title="三圈"></a>三圈</h2><p>这周相比于上周我处在<strong>舒适圈</strong>，主要原因是这周的任务少，比较轻松。不过这周别的事情也不少，去学校联系毕设呀，和快回家的同学吃饭聚会呀，年会呀，和考研的朋友谈心呀，果真是不管任务多少，都能拖拖拉拉做一个礼拜啊…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/23/summary_week2_2/" data-id="cjrc5774p0009qgowfc1zzk6e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/25/java_exception/">Java异常</a>
          </li>
        
          <li>
            <a href="/2019/01/20/notes_of_this/">this, call(), apply() 和bind()</a>
          </li>
        
          <li>
            <a href="/2019/01/19/summary_of_exam/">测评总结与反思</a>
          </li>
        
          <li>
            <a href="/2019/01/16/single_responsibility_principle/">单一职责原则</a>
          </li>
        
          <li>
            <a href="/2019/01/16/notes_of_java_foundation/">Java基础语法笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Song Nan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>