<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>宋博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="宋博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="宋博客">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="宋博客">
  
    <link rel="alternate" href="/atom.xml" title="宋博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">宋博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">我爱学习</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-summary_of_exam" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/19/summary_of_exam/" class="article-date">
  <time datetime="2019-01-19T15:12:43.045Z" itemprop="datePublished">2019-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/19/summary_of_exam/">测评总结与反思</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天早上还复习了三个多小时…也没什么用…</p>
<p>今天的测评结果很糟糕。</p>
<p>当然，测评结果不好的最最主要的原因就是自己学艺不精了。今天测评老师问我有看什么书来学习吗，我只能很尴尬地说没有…都没想过要去看这方面的书来更好地学习，一直以来都是任务卡学会了做好了感觉就好了，任务卡和链接里上没有的，线下培训没讲过的，基本都不会，因为很多东西都不知道，更说不上主动去学去了解了。而且其实任务卡上的东西，也没有说学的十分透彻，就是知道了啊这个是这个，那个是那个，它们的区别和联系，心里面好像都知道点，要说出来又不能说得清清楚楚有底气（就是没学好…）</p>
<p>还有就是今天CSS布局那道题，测评老师说我“没有章法”，这个确实，我写css就是边写边试，一般是心里有个想法，就开始一点一点试，试试改改就看起来是想要的样式了，有时候加的样式很多了，自己也不知道真正是哪几个样式互相配合有了这个效果。也是和上面一样，学习局限于任务卡，只要能达到作业要的效果就好，对于一些现在，怎么说，“商业”或者“专业”的网页布局是用什么方法实现的，和一些对于某一种布局的“专业称呼”——专有名词，都不太清楚。像今天那道布局题，要我自己写就会<code>float</code>加<code>margin</code>了，可能就只是从静态布局上看起来像那么回事了。对于CSS的学习，我想除了看书外，也可以多看看人家商业的、成熟的网站，在控制台，看看人家都是怎么实现的，怎么写的。</p>
<p>今天的测评，就主要暴露了两点吧，一个是“猪八戒吃人参果”，学的不细，还有就是太依赖于以及只着眼于任务卡，学的不全面不系统，今天测评老师也推荐了<strong>相关的书</strong>。其实我也有点话想说，培训也快三个月了，真的还挺累的，有每天培训地任务作业，有学校的事情，有生活上的事情，感觉好像每天，也不管做得任务多不多吧，都过得很紧张233，但是话又说回如来，像这样花了时间精力，却只学了个大概的话，也是对自己时间的浪费。<br>所以说，还是加油8~，生活一直很辛苦的说233┐(￣ヮ￣)┌<br><img src="http://ww1.sinaimg.cn/large/a85d55ddly1fzcbv5yvb2j208s07igly.jpg" alt=""></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/19/summary_of_exam/" data-id="cjr3nsrx50005h4owjh3qn5cw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-single_responsibility_principle" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/16/single_responsibility_principle/" class="article-date">
  <time datetime="2019-01-16T09:18:16.106Z" itemprop="datePublished">2019-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/16/single_responsibility_principle/">单一职责原则</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>单一职责原则</strong>（SRP：Single responsibility principle）又称单一功能原则，面向对象五个基本原则（SOLID）之一。它规定<strong>一个类应该只有一个发生变化的原因</strong>。</p>
<p>所谓<strong>职责</strong>是指类变化的原因。如果一个类有多于一个的动机被改变，那么这个类就具有多于一个的职责。而单一职责原则就是指一个类或者模块应该有且只有一个改变的原因。</p>
<p>单一职责原则的重要性在于，如果一个类拥有多于一个的职责，则这些职责就耦合到在了一起，那么就会有多于一个原因来导致这个类的变化。对于某一职责的更改可能会损害类满足其他耦合职责的能力。这样<strong>职责的耦合会导致设计的脆弱</strong>，以至于当职责发生更改时产生无法预期的破坏。</p>
<p>举一个网上的例子，<br><img src="https://images0.cnblogs.com/i/175043/201406/101818121707390.png" alt=""></p>
<p>上图图中的设计，类图中显示 <code>Rectangle</code> 类包含两个方法，一个方法（<code>Draw</code>）负责在显示屏幕上绘制矩形，另一个方法（<code>Area</code>）负责计算矩形图形面积。</p>
<p>有两个不同的应用程序均使用了 <code>Rectangle</code> 类。一个应用为计算几何程序(<code>ComputationalGeometryApplication</code>)，它使用了 <code>Rectangle</code> 中的数学几何模型，但不会在显示屏幕上绘制矩形。另一个应用是一个图形界面程序（<code>GUI</code>），它可能会做一些计算几何方面的工作，但主要功能是在屏幕上绘制矩形。</p>
<p>这个设计侵犯了 SRP 原则。<code>Rectangle</code> 类包含了两个职责。第一个职责是提供矩形几何计算的数学模型，第二个职责是在 <code>GUI</code> 上渲染矩形。</p>
<p>这会导致诸多难以解决的问题：</p>
<p>首先，我们必须在计算几何应用中包含对 <code>GUI</code> 库的引用。这导致应用程序无谓的<strong>消耗</strong>了链接时间、编译时间、内存空间和存储空间等。</p>
<p>再者，如果因为某些原因对 <code>GraphicalApplication</code> 的一个更改导致 <code>Rectangle</code> 类也相应做了更改，这将强制我们对 <code>ComputationalGeometryApplication</code> 进行重新编译、重新测试和重新部署等。如果我们忘了做这些事情，那么应用程序可能以<strong>无法预期</strong>的方式而<strong>崩溃</strong>。</p>
<p>所以，应当把这两个职责完全隔离到不同的类当中去。<br><img src="https://images0.cnblogs.com/i/175043/201406/101820070453862.png" alt=""><br>将 <code>Rectangle</code> 中关于几何计算的职责移到了 <code>GeometricRectangle</code> 类中，而 <code>Rectangle</code> 类中仅保留矩形渲染职责。这样，如果我们再对 <code>Rectangle</code> 中渲染职责进行更改时将不会再影响到 <code>ComputationalGeometryApplication</code> 了。</p>
<p>所以，为了代码的可读性和可维护性，以及为了解决资源，我们应当遵守单一职责原则。在之前js的学习中，有时候有的方法很简单，代码只有一行，我会把两个功能写进一个方法，这样就很不好，一个方法只做一件事，不论这件事有多简单，这应该成为一种习惯。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/16/single_responsibility_principle/" data-id="cjr3nsrwt0004h4owqwe2xont" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-notes_of_java_foundation" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/16/notes_of_java_foundation/" class="article-date">
  <time datetime="2019-01-16T08:03:10.190Z" itemprop="datePublished">2019-01-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/16/notes_of_java_foundation/">Java基础语法笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Java的主要特性"><a href="#Java的主要特性" class="headerlink" title="Java的主要特性"></a>Java的主要特性</h2><ol>
<li><strong>简单</strong>： Java语言是从C++ 发展起来的， 与此同时，Java取消了C++中复杂且难以掌握的东西，比如指针的，让Java的学习变得相对容易。</li>
<li><strong>面向对象</strong>： Java是一门面向对象设计的高级语言，面向对象设计是这门语言的灵魂。</li>
<li><strong>跨平台</strong>： Java语言编写的应用程序，不受平台限制，可以由一种平台迁移到另一种平台。</li>
<li><strong>解释性</strong>： Java是一门需要被编译解释的语言，使用java语言编写的源码被转化为字节码，字节码只有被Java虚拟机解释成机器码才能被计算机执行。</li>
<li><strong>健壮性</strong>： java提供了许多机制防止运行时出现严重错误，如编译时类型检查、异常处理。</li>
<li><strong>多线程</strong>： Java是一门高性能的语言，其中重要的原因是多线程的引入，能够极大的提升CPU的利用率</li>
</ol>
<p><a href="https://song-nan17.github.io/2019/01/14/jvm_jre_jdk/" target="_blank" rel="noopener">JVM, JRE,JDK的区别和联系</a></p>
<h2 id="变量，常量及方法"><a href="#变量，常量及方法" class="headerlink" title="变量，常量及方法"></a>变量，常量及方法</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>程序之中用来定义名称的都叫标识符，<strong>类名</strong>，<strong>变量名</strong>，<strong>方法名</strong>都被称为标识符。</p>
<h3 id="Java标识符命名规范："><a href="#Java标识符命名规范：" class="headerlink" title="Java标识符命名规范："></a>Java标识符命名规范：</h3><ul>
<li>所有的标识符都应该以<strong>字母</strong>(A-Z/a-z),<strong>美元符</strong>($)或者<strong>下划线</strong>(_)开始；</li>
<li>字符之后可以是字母(A-Z/a-z),美元符($),下划线(_)或数字的任何字符组合；</li>
<li>关键字不能用作标识符；</li>
<li>标识符是<strong>大小写敏感</strong>的。<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3>Java语言中的关键字：</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">int</th>
<th style="text-align:center">short</th>
<th style="text-align:center">try</th>
<th style="text-align:center">char</th>
<th style="text-align:center">final</th>
<th style="text-align:center">interface</th>
<th style="text-align:center">static</th>
<th style="text-align:center">void</th>
<th style="text-align:center">float</th>
<th style="text-align:center">native</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">abstract</td>
<td style="text-align:center">continue</td>
<td style="text-align:center">for</td>
<td style="text-align:center">new</td>
<td style="text-align:center">switch</td>
<td style="text-align:center">assert</td>
<td style="text-align:center">default</td>
<td style="text-align:center">goto</td>
<td style="text-align:center">super</td>
<td style="text-align:center">while</td>
</tr>
<tr>
<td style="text-align:center">package</td>
<td style="text-align:center">synchronized</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">do</td>
<td style="text-align:center">if</td>
<td style="text-align:center">private</td>
<td style="text-align:center">this</td>
<td style="text-align:center">break</td>
<td style="text-align:center">class</td>
<td style="text-align:center">finally</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">implements</td>
<td style="text-align:center">protected</td>
<td style="text-align:center">throw</td>
<td style="text-align:center">byte</td>
<td style="text-align:center">else</td>
<td style="text-align:center">import</td>
<td style="text-align:center">public</td>
<td style="text-align:center">long</td>
<td style="text-align:center">stricfp</td>
</tr>
<tr>
<td style="text-align:center">throws</td>
<td style="text-align:center">case</td>
<td style="text-align:center">enum</td>
<td style="text-align:center">instanceof</td>
<td style="text-align:center">return</td>
<td style="text-align:center">transient</td>
<td style="text-align:center">catch</td>
<td style="text-align:center">extends</td>
<td style="text-align:center">volatile</td>
<td style="text-align:center">const</td>
</tr>
</tbody>
</table>
<p><strong>另外</strong>：</p>
<ul>
<li><code>const</code>和<code>go</code>关键字虽然已经不在使用，但是他们还是被保留下来了。</li>
<li><code>true</code>，<code>false</code>，<code>null</code> 虽然被很多人误认为是关键字，但是实际上他们只是字面而已。<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3>Java语言定义了以下三种变量：</li>
<li><strong>局部变量</strong>：没有特殊的关键字将变量标记为局部变量，这完全取决于声明变量的位置——它<strong>位于方法的两个大括号之间</strong>。因此，局部变量只对声明它们的方法可见，对于类的其他部分来说它们是不可见的。</li>
<li><strong>类变量</strong>(静态域): 类变量是使用<code>static</code>关键字修饰的域。这告诉编译器无论这个类有多少个实例，这个变量<strong>只有一个副本</strong>。</li>
<li><strong>成员变量</strong>(非静态域)：从技术层面来说，对象将它们各自的状态存在“非静态域”中，也就是没有使用static关键字修饰的域。非静态域也被称为实例变量，因为对于类的每个实例（换句话说，就是每个对象）来说，它们的值都是独立的。<h4 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h4></li>
<li>变量属于标识符，因此必须符合标识符的命名规范。</li>
<li>变量的命名必须是有意义的，做到名如其意。</li>
<li>变量名最好用英文名词，禁止使用拼音。</li>
<li>变量名需要用小驼峰命名法<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3></li>
<li>通常用<code>final</code>关键字来声明</li>
<li>常量使用注意事项：<ul>
<li>常量在定义的时候，就需要对常量进行初始化。</li>
<li>常量一旦初始化之后，就不能再次对其赋值。</li>
<li><code>final</code>关键字不仅可以用来修饰基本数据类型的常量，还可以用来修饰对象的引用或者方法。</li>
<li><code>final</code>关键字与<code>static</code>关键字同时使用。<h4 id="常量命名规则"><a href="#常量命名规则" class="headerlink" title="常量命名规则"></a>常量命名规则</h4></li>
</ul>
</li>
<li>常量属于标识符，因此也必须要符合标识符的命名规范。</li>
<li>常量的命名必须要有具体的含义，做到名如其意。</li>
<li>常量名最好用英文名词， 禁止使用中文拼音。</li>
<li><p>常量名需要全部大写，相邻单词之间用下划线(_)隔开。如 final int PI = 3.1415927;等</p>
<h3 id="方法（函数）"><a href="#方法（函数）" class="headerlink" title="方法（函数）"></a>方法（函数）</h3><p>方法者，就是具有独立业务逻辑的代码集合</p>
<h4 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名) &#123;</span><br><span class="line">    方法体</span><br><span class="line">    return 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>修饰符：可选，告诉编译器如何调用该方法。定义了该方法的访问类型。</p>
</li>
<li>返回值类型： 就是<code>return</code>之后的返回值的类型，有些方法可能没有返回值，用关键字<code>void</code>来表示。</li>
<li>方法名：就是方法的名字，必须符合一定的命名规范。</li>
<li>参数：由参数类型和参数名称组成。参数名是一个变量，用于接收调用方法时传入的数据。</li>
<li>方法体：被封装的独立代码块，是方法的核心部分，处理重要的业务逻辑。</li>
</ul>
<p>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public int getMaxValue(int val1, int val2) &#123;</span><br><span class="line">    int result = val1 &gt;= val2 ? val1 : val2;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：方法体遵循单一职责原则，即每个方法就仅仅做一件事情，这样可以增加可读性和可维护性。</p>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><p>与js中相同，调用方法名并传入相应的参数即可。例如上面方法调用为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int maxValue = getMaxValue(2, 3);</span><br></pre></td></tr></table></figure></p>
<h4 id="方法的命名规则："><a href="#方法的命名规则：" class="headerlink" title="方法的命名规则："></a>方法的命名规则：</h4><ul>
<li>方法名属于标识符，因此也必须要符合标识符的命名规范。</li>
<li>方法的命名必须要有具体的含义，做到名如其意。</li>
<li>方法名最好用英文动词，表示一个动作，禁止使用中文拼音。</li>
<li>方法名需要用小驼峰命名法，首字母小写，后面的单词需首字母大写，来用区分相邻单词。</li>
</ul>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Java语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>
<h3 id="byte："><a href="#byte：" class="headerlink" title="byte："></a>byte：</h3><ul>
<li><code>byte</code> 数据类型是<code>8</code>位、有符号的，以二进制补码表示的整数；</li>
<li>最小值是 <code>-128</code>（<code>-2^7</code>）；</li>
<li>最大值是 <code>127</code>（<code>2^7-1</code>）；</li>
<li>默认值是 <code>0</code>；</li>
<li><code>byte</code> 类型用在大型数组中节约空间，主要代替整数，因为 <code>byte</code> 变量占用的空间只有 int 类型的四分之一；</li>
<li>例子：<code>byte a = 100，byte b = -50</code>。<h3 id="short："><a href="#short：" class="headerlink" title="short："></a>short：</h3></li>
<li><code>short</code> 数据类型是 <code>16</code> 位、有符号的以二进制补码表示的整数</li>
<li>最小值是 <code>-32768</code>（<code>-2^15</code>）；</li>
<li>最大值是 <code>32767</code>（<code>2^15 - 1</code>）；</li>
<li><code>Short</code> 数据类型也可以像 <code>byte</code> 那样节省空间。一个<code>short</code>变量是<code>int</code>型变量所占空间的二分之一；</li>
<li>默认值是<code>0</code>；</li>
<li>例子：<code>short s = 1000，short r = -20000</code>。<h3 id="int："><a href="#int：" class="headerlink" title="int："></a>int：</h3></li>
<li><code>int</code> 数据类型是<code>32</code>位、有符号的以二进制补码表示的整数；</li>
<li>最小值是 <code>-2,147,483,648</code>（<code>-2^31</code>）；</li>
<li>最大值是 <code>2,147,483,647</code>（<code>2^31 - 1</code>）；</li>
<li>一般地整型变量默认为 <code>int</code> 类型；</li>
<li>默认值是 <code>0</code> ；</li>
<li>例子：<code>int a = 100000, int b = -200000</code>。<h3 id="long："><a href="#long：" class="headerlink" title="long："></a>long：</h3></li>
<li><code>long</code> 数据类型是 <code>64</code> 位、有符号的以二进制补码表示的整数；</li>
<li>最小值是 <code>-9,223,372,036,854,775,808</code>（<code>-2^63</code>）；</li>
<li>最大值是 <code>9,223,372,036,854,775,807</code>（<code>2^63 -1</code>）；</li>
<li>这种类型主要使用在需要比较大整数的系统上；</li>
<li>默认值是 <code>0L</code>；</li>
<li>整数字面量默认都为 <code>int</code> 类型，所以在定义的 <code>long</code> 型数据后面加 <code>L</code>或 <code>l</code>。</li>
<li>例子： <code>long a = 100000L，Long b = -200000L</code>。</li>
<li>“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。<h3 id="float："><a href="#float：" class="headerlink" title="float："></a>float：</h3></li>
<li><code>float</code> 数据类型是单精度、<code>32</code>位、符合IEEE 754标准的浮点数；</li>
<li><code>float</code> 在储存大型浮点数组的时候可节省内存空间；</li>
<li>默认值是 <code>0.0f</code>；</li>
<li>浮点数字面量默认都为 <code>double</code> 类型，所以在定义的 <code>float</code> 型数据后面加<code>F</code> 或 <code>f</code>；</li>
<li><code>double</code> 类型可不写后缀，但在小数计算中一定要写 <code>D</code> 或 <code>X.X</code> </li>
<li>浮点数不能用来表示精确的值，如货币；</li>
<li>例子：<code>float f1 = 234.5f</code>。<h3 id="double："><a href="#double：" class="headerlink" title="double："></a>double：</h3></li>
<li><code>double</code> 数据类型是双精度、<code>64</code> 位、符合IEEE 754标准的浮点数；</li>
<li>浮点数的默认类型为<code>double</code>类型；</li>
<li><code>double</code>类型同样不能表示精确的值，如货币；</li>
<li>默认值是 <code>0.0d</code>；</li>
<li>例子：<code>double d1 = 123.4</code>。<h3 id="boolean："><a href="#boolean：" class="headerlink" title="boolean："></a>boolean：</h3></li>
<li><code>boolean</code>数据类型表示一位的信息；</li>
<li>只有两个取值：<code>true</code> 和 <code>false</code>；</li>
<li>这种类型只作为一种标志来记录 <code>true</code>/<code>false</code> 情况；</li>
<li>默认值是 <code>false</code>；</li>
<li>例子：<code>boolean one = true</code>。<h3 id="char："><a href="#char：" class="headerlink" title="char："></a>char：</h3></li>
<li><code>char</code>类型是一个单一的 <code>16</code> 位 <code>Unicode</code> 字符；</li>
<li>最小值是 <code>\u0000</code>（即为<code>0</code>）；</li>
<li>最大值是 <code>\uffff</code>（即为<code>65,535</code>）；</li>
<li><code>char</code> 数据类型可以储存任何字符；</li>
<li>例子：<code>char letter = &#39;A&#39;;</code>。</li>
</ul>
<p>实际上，JAVA中还存在另外一种基本类型void，它也有对应的包装类 java.lang.Void，不过我们无法直接对它们进行操作。</p>
<h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。</p>
<p>转换从低级到高级。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">低  ------------------------------------&gt;  高</span><br><span class="line"></span><br><span class="line">byte,short,char—&gt; int —&gt; long—&gt; float —&gt; double</span><br></pre></td></tr></table></figure></p>
<p>数据类型转换必须满足如下规则：</p>
<ol>
<li><p>不能对boolean类型进行类型转换。</p>
</li>
<li><p>不能把对象类型转换成不相关类的对象。</p>
</li>
<li><p>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</p>
</li>
<li><p>转换过程中可能导致溢出或损失精度，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int i =128;   </span><br><span class="line">byte b = (byte)i;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>因为 byte 类型是 8 位，最大值为127，所以当 int 强制转换为 byte 类型时，值 128 时候就会导致溢出。</p>
<ol start="5">
<li>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入，例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(int)23.7 == 23;        </span><br><span class="line">(int)-45.89f == -45</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>必须满足<strong>转换前的数据类型的位数要低于转换后的数据类型</strong>，例如: <code>short</code>数据类型的位数为16位，就可以自动转换位数为32的<code>int</code>类型，同样<code>float</code>数据类型的位数为<code>32</code>，可以自动转换为64位的<code>double</code>类型。</p>
<h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><ol>
<li><p>条件是转换的数据类型必须是兼容的。</p>
</li>
<li><p>格式：<code>(type)value type</code>是要强制类型转换后的数据类型</p>
</li>
</ol>
<p>实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class QiangZhiZhuanHuan&#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        int i1 = 123;</span><br><span class="line">        byte b = (byte)i1;//强制类型转换为byte</span><br><span class="line">        System.out.println(&quot;int强制类型转换为byte后的值等于&quot;+b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int强制类型转换为byte后的值等于123</span><br></pre></td></tr></table></figure></p>
<h3 id="隐含强制类型转换"><a href="#隐含强制类型转换" class="headerlink" title="隐含强制类型转换"></a>隐含强制类型转换</h3><ol>
<li><p>整数的默认类型是 <code>int</code>。</p>
</li>
<li><p>浮点型不存在这种情况，因为在定义 <code>float</code> 类型时必须在数字后面跟上 <code>F</code> 或者 <code>f</code>。</p>
</li>
</ol>
<h2 id="java运算符"><a href="#java运算符" class="headerlink" title="java运算符"></a>java运算符</h2><p><a href="http://www.runoob.com/java/java-operators.html" target="_blank" rel="noopener">java运算符</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/16/notes_of_java_foundation/" data-id="cjr3nss05000hh4ow1xtv7xku" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-IntelliJ-IDEA-Tutorial" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/15/IntelliJ-IDEA-Tutorial/" class="article-date">
  <time datetime="2019-01-15T13:14:28.609Z" itemprop="datePublished">2019-01-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/15/IntelliJ-IDEA-Tutorial/">初级IntelliJ IDEA使用总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>对于IntelliJ IDEA的使用方法，我主要是学习了<a href="https://blog.csdn.net/jiangyu1013/article/details/78780261" target="_blank" rel="noopener">java初学者教程</a>和<a href="https://github.com/judasn/IntelliJ-IDEA-Tutorial" target="_blank" rel="noopener">https://github.com/judasn/IntelliJ-IDEA-Tutorial</a>两篇教程。</p>
<p>第二篇教程内容非常丰富，教程中有将IntelliJ IDEA和其他IDE对比，特别是和Eclipse.因为我之前并没有使用过Eclipse,也没有java项目开发经验，很多内容看起来头大…所以只学习了教程中的基础设置、快捷键,和IntelliJ IDEA的特别之处。</p>
<h2 id="开始一个小项目"><a href="#开始一个小项目" class="headerlink" title="开始一个小项目"></a>开始一个小项目</h2><p>启动IDEA后点击<code>Create New Projec</code>新建一个java项目<br><img src="http://ww1.sinaimg.cn/large/a85d55ddly1fz8dv0wyb5j20k00jzt9g.jpg" alt=""></p>
<p>左列默认新建java项目，右侧<code>new</code>配置JDK主目录。点击<code>next</code>设置项目名称和项目地址。</p>
<p>新建的项目目录如下：<br><img src="http://ww1.sinaimg.cn/large/a85d55ddly1fz8e73moagj20pl0e73z6.jpg" alt=""></p>
<p>新建了一个名为<code>HelloWorld</code>的项目。基本上所有的IntelliJ IDEA使用教程都会提到，在 IntelliJ IDEA 中 Project 是最顶级的级别，次级别是 Module。一个 Project 可以有多个 Module。而像上图则是只有一个Module的项目，所以Project 目录和 Module 目录是同一个，名为<code>HelloWorld</code>,而<code>src</code>实际上是Module下的目录。<code>.idea</code>和<code>HelloWorld.iml</code>是IDEA帮助我们建立的辅助文件夹和文件。<code>External Libraries</code>是引入的类库，目前只有JDK。<br>选中<code>src</code>目录，右键-&gt;<code>new</code>即可在<code>src</code>目录下新建不同类型的文件，如<code>java class</code>。</p>
<h2 id="IntelliJ-IDEA-编译和运行"><a href="#IntelliJ-IDEA-编译和运行" class="headerlink" title="IntelliJ IDEA 编译和运行"></a>IntelliJ IDEA 编译和运行</h2><p>在 IntelliJ IDEA 里，编译方式一共有三种：</p>
<ul>
<li><code>Compile</code>：对选定的目标（Java 类文件），进行强制性编译，不管目标是否是被修改过。注：2018版操作为<code>Recompile</code>。</li>
<li><code>Rebuild</code>：对选定的目标（Project），进行强制性编译，不管目标是否是被修改过，由于<code>Rebuild</code>的目标只有 Project，所以 <code>Rebuild</code> 每次花的时间会比较长。</li>
<li><code>Make</code>：使用最多的编译操作。对选定的目标（Project 或 Module）进行编译，但只编译有修改过的文件，没有修改过的文件不会编译，这样平时开发大型项目才不会浪费时间在编译过程中。注：2018版操作为<code>Build</code>。</li>
</ul>
<p>在菜单<code>Build</code>栏下即找到到三种编译的操作。</p>
<p>而在代码编辑区空白处右键或菜单栏<code>Run</code>都可以看到<code>Run</code>方法，运行代码。</p>
<h2 id="字体修改"><a href="#字体修改" class="headerlink" title="字体修改"></a>字体修改</h2><p>为了尽可能避免中文显示乱码和使界面更美观，可以修改字体。注意，我们应选择包含中文的字体。</p>
<ul>
<li><p>主题字体修改<br><img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-b-font-setting-1.jpg" alt=""></p>
</li>
<li><p>代码编辑字体修改<br><img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-b-font-setting-2.jpg" alt=""></p>
</li>
<li><p>控制台输出字体修改<br><img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/x-b-font-setting-3.jpg" alt=""></p>
</li>
</ul>
<h2 id="IntelliJ-IDEA快捷键"><a href="#IntelliJ-IDEA快捷键" class="headerlink" title="IntelliJ IDEA快捷键"></a>IntelliJ IDEA快捷键</h2><p>首先最好是去掉一些输入法，如搜狗输入法的快捷键。</p>
<p>IntelliJ IDEA快捷键：</p>
<h3 id="Ctrl"><a href="#Ctrl" class="headerlink" title="Ctrl"></a>Ctrl</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ctrl</code> + <code>F</code></td>
<td>在当前文件进行文本查找 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>R</code></td>
<td>在当前文件进行文本替换 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Z</code></td>
<td>撤销 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Y</code></td>
<td>删除光标所在行 或 删除选中的行 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>X</code></td>
<td>剪切光标所在行 或 剪切选择内容</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>C</code></td>
<td>复制光标所在行 或 复制选择内容</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>D</code></td>
<td>复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>W</code></td>
<td>递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>E</code></td>
<td>显示最近打开的文件记录列表 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>N</code></td>
<td>根据输入的 类名 查找类文件 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>G</code></td>
<td>在当前文件跳转到指定行处</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>J</code></td>
<td>插入自定义动态代码模板 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>P</code></td>
<td>方法参数提示显示 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Q</code></td>
<td>光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>U</code></td>
<td>前往当前光标所在的方法的父类的方法 / 接口定义 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>B</code></td>
<td>进入光标所在的方法/变量的接口或是定义处，等效于 <code>Ctrl</code> + <code>左键单击</code> <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>K</code></td>
<td>版本控制提交项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>T</code></td>
<td>版本控制更新项目，需要此项目有加入到版本控制才可用</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>H</code></td>
<td>显示当前类的层次结构</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>O</code></td>
<td>选择可重写的方法</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>I</code></td>
<td>选择可继承的方法</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>+</code></td>
<td>展开代码</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>-</code></td>
<td>折叠代码</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>/</code></td>
<td>注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>[</code></td>
<td>移动光标到当前所在代码的花括号开始位置</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>]</code></td>
<td>移动光标到当前所在代码的花括号结束位置</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>F1</code></td>
<td>在光标所在的错误代码处显示错误信息 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>F3</code></td>
<td>调转到所选中的词的下一个引用位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>F4</code></td>
<td>关闭当前编辑文件</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>F8</code></td>
<td>在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>F9</code></td>
<td>执行 Make Project 操作</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>F11</code></td>
<td>选中文件 / 文件夹，使用助记符设定 / 取消书签 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>F12</code></td>
<td>弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Tab</code></td>
<td>编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>End</code></td>
<td>跳到文件尾</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Home</code></td>
<td>跳到文件头</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Space</code></td>
<td>基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 <code>Ctrl</code> + <code>逗号</code> <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Delete</code></td>
<td>删除光标后面的单词或是中文句 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>BackSpace</code></td>
<td>删除光标前面的单词或是中文句 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>1,2,3...9</code></td>
<td>定位到对应数值的书签位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>左键单击</code></td>
<td>在打开的文件标题上，弹出该文件路径 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>光标定位</code></td>
<td>按 Ctrl 不要松开，会显示光标所在的类信息摘要</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>左方向键</code></td>
<td>光标跳转到当前单词 / 中文句的左侧开头位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>右方向键</code></td>
<td>光标跳转到当前单词 / 中文句的右侧开头位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>前方向键</code></td>
<td>等效于鼠标滚轮向前效果 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>后方向键</code></td>
<td>等效于鼠标滚轮向后效果 <code>（必备）</code></td>
</tr>
</tbody>
</table>
<h3 id="Alt"><a href="#Alt" class="headerlink" title="Alt"></a>Alt</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Alt</code> + <code>反引号</code></td>
<td>显示版本控制常用操作菜单弹出层 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>Q</code></td>
<td>弹出一个提示，显示当前类的声明 / 上下文信息</td>
</tr>
<tr>
<td><code>Alt</code> + <code>F1</code></td>
<td>显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>F2</code></td>
<td>对于前面页面，显示各类浏览器打开目标选择弹出层</td>
</tr>
<tr>
<td><code>Alt</code> + <code>F3</code></td>
<td>选中文本，逐个往下查找相同文本，并高亮显示</td>
</tr>
<tr>
<td><code>Alt</code> + <code>F7</code></td>
<td>查找光标所在的方法 / 变量 / 类被调用的地方</td>
</tr>
<tr>
<td><code>Alt</code> + <code>F8</code></td>
<td>在 <code>Debug</code> 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果</td>
</tr>
<tr>
<td><code>Alt</code> + <code>Home</code></td>
<td>定位 / 显示到当前文件的 <code>Navigation Bar</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>Enter</code></td>
<td>IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>Insert</code></td>
<td>代码自动生成，如生成对象的 <code>set</code> / <code>get</code> 方法，构造函数，<code>toString()</code> 等 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>左方向键</code></td>
<td>切换当前已打开的窗口中的子视图，比如<code>Debug</code>窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>右方向键</code></td>
<td>按切换当前已打开的窗口中的子视图，比如<code>Debug</code>窗口中有Output、Debugger等子视图，用此快捷键就可以在子视图中切换 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>前方向键</code></td>
<td>当前光标跳转到当前文件的前一个方法名位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>后方向键</code></td>
<td>当前光标跳转到当前文件的后一个方法名位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>1,2,3...9</code></td>
<td>显示对应数值的选项卡，其中 <code>1</code> 是 Project 用得最多 <code>（必备）</code></td>
</tr>
</tbody>
</table>
<h3 id="Shift"><a href="#Shift" class="headerlink" title="Shift"></a>Shift</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Shift</code> + <code>F1</code></td>
<td>如果有外部文档可以连接外部文档</td>
</tr>
<tr>
<td><code>Shift</code> + <code>F2</code></td>
<td>跳转到上一个高亮错误 或 警告位置</td>
</tr>
<tr>
<td><code>Shift</code> + <code>F3</code></td>
<td>在查找模式下，查找匹配上一个</td>
</tr>
<tr>
<td><code>Shift</code> + <code>F4</code></td>
<td>对当前打开的文件，使用新Windows窗口打开，旧窗口保留</td>
</tr>
<tr>
<td><code>Shift</code> + <code>F6</code></td>
<td>对文件 / 文件夹 重命名</td>
</tr>
<tr>
<td><code>Shift</code> + <code>F7</code></td>
<td>在 <code>Debug</code> 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法</td>
</tr>
<tr>
<td><code>Shift</code> + <code>F8</code></td>
<td>在 <code>Debug</code> 模式下，跳出，表现出来的效果跟 <code>F9</code> 一样</td>
</tr>
<tr>
<td><code>Shift</code> + <code>F9</code></td>
<td>等效于点击工具栏的 <code>Debug</code> 按钮</td>
</tr>
<tr>
<td><code>Shift</code> + <code>F10</code></td>
<td>等效于点击工具栏的 <code>Run</code> 按钮</td>
</tr>
<tr>
<td><code>Shift</code> + <code>F11</code></td>
<td>弹出书签显示层 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Shift</code> + <code>Tab</code></td>
<td>取消缩进 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Shift</code> + <code>ESC</code></td>
<td>隐藏当前 或 最后一个激活的工具窗口</td>
</tr>
<tr>
<td><code>Shift</code> + <code>End</code></td>
<td>选中光标到当前行尾位置</td>
</tr>
<tr>
<td><code>Shift</code> + <code>Home</code></td>
<td>选中光标到当前行头位置</td>
</tr>
<tr>
<td><code>Shift</code> + <code>Enter</code></td>
<td>开始新一行。光标所在行下空出一行，光标定位到新行位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Shift</code> + <code>左键单击</code></td>
<td>在打开的文件名上按此快捷键，可以关闭当前打开文件 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Shift</code> + <code>滚轮前后滚动</code></td>
<td>当前文件的横向滚动轴滚动 <code>（必备）</code></td>
</tr>
</tbody>
</table>
<h3 id="Ctrl-Alt"><a href="#Ctrl-Alt" class="headerlink" title="Ctrl + Alt"></a>Ctrl + Alt</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>L</code></td>
<td>格式化代码，可以对当前文件和整个包目录使用 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>O</code></td>
<td>优化导入的类，可以对当前文件和整个包目录使用 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>I</code></td>
<td>光标所在行 或 选中部分进行自动代码缩进，有点类似格式化</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>T</code></td>
<td>对选中的代码弹出环绕选项弹出层 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>J</code></td>
<td>弹出模板选择窗口，将选定的代码加入动态模板中</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>H</code></td>
<td>调用层次</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>B</code></td>
<td>在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>C</code></td>
<td>重构-快速提取常量</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>F</code></td>
<td>重构-快速提取成员变量</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>V</code></td>
<td>重构-快速提取变量</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>Y</code></td>
<td>同步、刷新</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>S</code></td>
<td>打开 IntelliJ IDEA 系统设置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>F7</code></td>
<td>显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>F11</code></td>
<td>切换全屏模式</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>Enter</code></td>
<td>光标所在行上空出一行，光标定位到新行 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>Home</code></td>
<td>弹出跟当前文件有关联的文件弹出层</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>Space</code></td>
<td>类名自动完成</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>左方向键</code></td>
<td>退回到上一个操作的地方 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>右方向键</code></td>
<td>前进到上一个操作的地方 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>前方向键</code></td>
<td>在查找模式下，跳到上个查找的文件</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>后方向键</code></td>
<td>在查找模式下，跳到下个查找的文件</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>右括号（]）</code></td>
<td>在打开多个项目的情况下，切换下一个项目窗口</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Alt</code> + <code>左括号（[）</code></td>
<td>在打开多个项目的情况下，切换上一个项目窗口</td>
</tr>
</tbody>
</table>
<h3 id="Ctrl-Shift"><a href="#Ctrl-Shift" class="headerlink" title="Ctrl + Shift"></a>Ctrl + Shift</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>F</code></td>
<td>根据输入内容查找整个项目 或 指定目录内文件 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>R</code></td>
<td>根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>J</code></td>
<td>自动将下一行合并到当前行末尾 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Z</code></td>
<td>取消撤销 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>W</code></td>
<td>递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>N</code></td>
<td>通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>U</code></td>
<td>对选中的代码进行大 / 小写轮流转换 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>T</code></td>
<td>对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>C</code></td>
<td>复制当前文件磁盘路径到剪贴板 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>V</code></td>
<td>弹出缓存的最近拷贝的内容管理器弹出层</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>E</code></td>
<td>显示最近修改的文件列表的弹出层</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>H</code></td>
<td>显示方法层次结构</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>B</code></td>
<td>跳转到类型声明处 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>I</code></td>
<td>快速查看光标所在的方法 或 类的定义</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>A</code></td>
<td>查找动作 / 设置</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>/</code></td>
<td>代码块注释 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>[</code></td>
<td>选中从光标所在位置到它的顶部中括号位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>]</code></td>
<td>选中从光标所在位置到它的底部中括号位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>+</code></td>
<td>展开所有代码 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>-</code></td>
<td>折叠所有代码 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>F7</code></td>
<td>高亮显示所有该选中文本，按Esc高亮消失 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>F8</code></td>
<td>在 <code>Debug</code> 模式下，指定断点进入条件</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>F9</code></td>
<td>编译选中的文件 / 包 / Module</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>F12</code></td>
<td>编辑器最大化 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Space</code></td>
<td>智能代码提示</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Enter</code></td>
<td>自动结束代码，行末自动添加分号 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Backspace</code></td>
<td>退回到上次修改的地方 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>1,2,3...9</code></td>
<td>快速添加指定数值的书签 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>左键单击</code></td>
<td>把光标放在某个类变量上，按此快捷键可以直接定位到该类中 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>左方向键</code></td>
<td>在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>右方向键</code></td>
<td>在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>前方向键</code></td>
<td>光标放在方法名上，将方法移动到上一个方法前面，调整方法排序 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>后方向键</code></td>
<td>光标放在方法名上，将方法移动到下一个方法前面，调整方法排序 <code>（必备）</code></td>
</tr>
</tbody>
</table>
<h3 id="Alt-Shift"><a href="#Alt-Shift" class="headerlink" title="Alt + Shift"></a>Alt + Shift</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>N</code></td>
<td>选择 / 添加 <code>task</code>  <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>F</code></td>
<td>显示添加到收藏夹弹出层 / 添加到收藏夹</td>
</tr>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>C</code></td>
<td>查看最近操作项目的变化情况列表</td>
</tr>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>I</code></td>
<td>查看项目当前文件</td>
</tr>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>F7</code></td>
<td>在 <code>Debug</code> 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入</td>
</tr>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>F9</code></td>
<td>弹出 <code>Debug</code> 的可选择菜单</td>
</tr>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>F10</code></td>
<td>弹出 <code>Run</code> 的可选择菜单</td>
</tr>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>左键双击</code></td>
<td>选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>前方向键</code></td>
<td>移动光标所在行向上移动 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Alt</code> + <code>Shift</code> + <code>后方向键</code></td>
<td>移动光标所在行向下移动 <code>（必备）</code></td>
</tr>
</tbody>
</table>
<h3 id="Ctrl-Shift-Alt"><a href="#Ctrl-Shift-Alt" class="headerlink" title="Ctrl + Shift + Alt"></a>Ctrl + Shift + Alt</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Alt</code> + <code>V</code></td>
<td>无格式黏贴 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Alt</code> + <code>N</code></td>
<td>前往指定的变量 / 方法</td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Alt</code> + <code>S</code></td>
<td>打开当前项目设置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Ctrl</code> + <code>Shift</code> + <code>Alt</code> + <code>C</code></td>
<td>复制参考信息</td>
</tr>
</tbody>
</table>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><table>
<thead>
<tr>
<th>快捷键</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>F2</code></td>
<td>跳转到下一个高亮错误 或 警告位置 <code>（必备）</code></td>
</tr>
<tr>
<td><code>F3</code></td>
<td>在查找模式下，定位到下一个匹配处</td>
</tr>
<tr>
<td><code>F4</code></td>
<td>编辑源 <code>（必备）</code></td>
</tr>
<tr>
<td><code>F7</code></td>
<td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中</td>
</tr>
<tr>
<td><code>F8</code></td>
<td>在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内</td>
</tr>
<tr>
<td><code>F9</code></td>
<td>在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上</td>
</tr>
<tr>
<td><code>F11</code></td>
<td>添加书签 <code>（必备）</code></td>
</tr>
<tr>
<td><code>F12</code></td>
<td>回到前一个工具窗口 <code>（必备）</code></td>
</tr>
<tr>
<td><code>Tab</code></td>
<td>缩进 <code>（必备）</code></td>
</tr>
<tr>
<td><code>ESC</code></td>
<td>从工具窗口进入代码文件窗口 <code>（必备）</code></td>
</tr>
<tr>
<td><code>连按两次Shift</code></td>
<td>弹出 <code>Search Everywhere</code> 弹出层</td>
</tr>
</tbody>
</table>
<h3 id="快捷键修改"><a href="#快捷键修改" class="headerlink" title="快捷键修改"></a>快捷键修改</h3><p><code>setting</code>-&gt;<code>keymap</code></p>
<p><img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/xxvii-a-keymap-setting-1.jpg" alt=""></p>
<ul>
<li>可以通过上图<code>1</code>所示的，通过输入快捷键描述内容；还可以上图标注 <code>2</code> 所示的，通过<strong>按</strong>指定快捷键的快捷键。</li>
<li>上图标注 <code>3</code> 所示，初安装的 IntelliJ IDEA 使用的是 Default 的快捷键模板，IntelliJ IDEA 默认的快捷键模板都是不可修改的。如果直接修改，当前这个位置 IntelliJ IDEA 会自动变成 Default Copy，教程中建议养成习惯，修改之前先点击 Copy，拷贝一套快捷键模板，然后输入自己的命名。</li>
</ul>
<p><img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/xxvii-a-keymap-setting-2.jpg" alt=""></p>
<ul>
<li>要修改某个快捷键，选中快捷键介绍内容，右键，就会弹出如上图标注 <code>1</code> 所示操作选择。</li>
<li>命令 <code>Add Keyboard Shortcut</code> 用来添加新纯键盘快捷键组合。</li>
<li>命令 <code>Add Mouse Shortcut</code> 用来添加新 键盘 + 鼠标 快捷键组合，比如设置 <code>Ctrl</code> + <code>左键单击</code> 这类快捷组合。其中在弹出的添加面板中 <code>Click Pad</code> 是用来监听当前鼠标是左键单击还是右键单击。 </li>
<li>命令 <code>Remove</code> 快捷键 移出当前操作命令已设置的快捷键组合。</li>
</ul>
<h2 id="常见文件类型的图标介绍"><a href="#常见文件类型的图标介绍" class="headerlink" title="常见文件类型的图标介绍"></a>常见文件类型的图标介绍</h2><h3 id="Java-类相关图标介绍"><a href="#Java-类相关图标介绍" class="headerlink" title="Java 类相关图标介绍"></a>Java 类相关图标介绍</h3><p><img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/xi-a-file-symbols-1.jpg" alt=""></p>
<ul>
<li><p>官网地址：<a href="http://www.jetbrains.com/idea/webhelp/symbols.html" target="_blank" rel="noopener">http://www.jetbrains.com/idea/webhelp/symbols.html</a></p>
</li>
<li><p><img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/xi-a-file-symbols-2.gif" alt=""><br><code>Source root</code>，可以理解为源目录，源码的作用就是用来专门放 <code>Java</code> 类文件，相对于编译出来的 <code>class</code> 文件而言，它就是源。我们一般默认名字叫 <code>src</code> 的目录就是源目录，但是其实并不是这样的，在 IntelliJ IDEA 中，即使叫 srcs 也是可以设置为 Source root，所以源目录跟目录命名是没有关系的，而是在于 IntelliJ IDEA 支持对任意目录进行设置为 Source 可以在文头的第二个教程中查找。</p>
</li>
<li><img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/xi-a-file-symbols-3.png" alt=""> <code>Java class located out of the source root</code>，如果 <code>Java</code> 类文件没有放在该目录或是该目录的子包下，那该 <code>Java</code> 类则无法编译，就会被表示成这个图标。<h3 id="各类文件类型图标介绍"><a href="#各类文件类型图标介绍" class="headerlink" title="各类文件类型图标介绍"></a>各类文件类型图标介绍</h3><img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/xi-b-file-symbols-1.jpg" alt=""></li>
<li>官网地址：<a href="http://www.jetbrains.com/idea/webhelp/file-types-recognized-by-intellij-idea.html" target="_blank" rel="noopener">http://www.jetbrains.com/idea/webhelp/file-types-recognized-by-intellij-idea.html</a></li>
<li>JavaScript 两种图标介绍<img src="https://github.com/judasn/IntelliJ-IDEA-Tutorial/raw/master/images/xi-b-file-symbols-2.png" alt=""></li>
<li>如上图所示，对于压缩过的 JavaScript 文件，图标会有 <code>010</code>图案。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/15/IntelliJ-IDEA-Tutorial/" data-id="cjr3nss1w000kh4owh3hauamb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jvm_jre_jdk" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/14/jvm_jre_jdk/" class="article-date">
  <time datetime="2019-01-14T14:29:34.794Z" itemprop="datePublished">2019-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/14/jvm_jre_jdk/">JVM, JRE, JDK 的区别和联系</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM是JavaVirtual Machine（<strong>Java虚拟机</strong>）的缩写，它是整个java实现跨平台的最核心的部分，不是 Java 能够跨平台，而是它的 jvm 能够跨平台。</p>
<p>所有的java程序会首先被编译为<code>.class</code>的类文件，这种类文件可以在虚拟机上执行，也就是说<code>.class</code>并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</p>
<p>JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p>
<p>JVM也有自己的指令集，并且在运行时操作不同的内存区域。 JVM的主要工作是解释自己的指令集（即字节码）到CPU的指令集或对应的系统调用，保护用户免被恶意程序骚扰。 JVM对上层的Java源文件是不关心的，它关注的只是由源文件生成的类文件（<code>.class</code>文件）。</p>
<h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h2><p>JRE是java runtime environment（<strong>java运行环境</strong>）的缩写。</p>
<p>光有JVM还不能让<code>.class</code>文件执行，因为在解释<code>.class</code>的时候JVM需要调用解释所需要的类库<code>lib</code>。在JDK的安装目录里可以找到<code>jre</code>目录，里面有两个文件夹<code>bin</code>和<code>lib</code>,在这里可以认为<code>bin</code>里的就是<code>jvm</code>，<code>lib</code>中则是<code>jvm</code>工作所需要的类库，而<code>jvm</code>和<code>lib</code>和起来就称为<code>jre</code>。</p>
<p>JRE是Java运行环境，并不是一个开发环境，所以没有包含任何开发工具（如编译器和调试器），是提供给用户来直接使用运行编译后的java程序的。</p>
<h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>JDK是java development kit（<strong>java开发工具包</strong>）的缩写,是Sun Microsystems针对Java开发员的产品。</p>
<p>在JDK安装目录下面有六个文件夹、一个<code>src</code>类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：<code>bin</code>、<code>include</code>、<code>lib</code>、<code>jre</code>。</p>
<ul>
<li><p><code>bin</code>:最主要的是编译器(javac.exe)</p>
</li>
<li><p><code>include</code>:java和JVM交互用的头文件</p>
</li>
<li><p><code>lib</code>：类库 （java开发需要的类库）    </p>
</li>
<li><p><code>jre</code>:java运行环境 </p>
</li>
</ul>
<p>(eclipse、idea等其他IDE(集成开发环境)有自己的编译器而不是用JDK bin目录中自带的，所以在安装时只要求选jre路径)</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>由安装目录可以看出这样一个关系：<strong>JDK包含JRE，而JRE包含JVM</strong>。jdk是用来java程序开发的，而jre是只能运行<code>class</code>而没有编译的功能，jre是java能够跨平台运行的核心。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/14/jvm_jre_jdk/" data-id="cjr3nsru40000h4owmay73ll1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-summary_week5_2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/13/summary_week5_2/" class="article-date">
  <time datetime="2019-01-13T13:21:18.266Z" itemprop="datePublished">2019-01-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/13/summary_week5_2/">总结—第一阶段第五周</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>上周忘记写总结了…这两周就是在做<code>todo-list</code>和思沃影院。做这两个作业时，回顾、应用了很多以前学习的知识，对以前学习的内容有了更好的掌握。<code>HTML</code>和<code>CSS</code>是必不可少的，不用说。做<code>todo-list</code>是用了很多的事件监听和事件代理，以及<code>DOM</code>方法和属性，<code>localStorage</code>方法。完成<code>todo-list</code>后，做思沃影院更好做了。如显示推荐电影和分类电影就采用了<code>todod-list</code>里显示<code>todos</code>的方法，而随机推荐不重复的高分电影和轮播图则是想到了之前打地鼠作业里控制地鼠随机连续出动的方法完成的。可见，还是要多练，可能刚学的时候没有很深的感受，通过练习后就能理解的更好也掌握的更好。</p>
<p>做思沃影院时也学到了一些新方法，如<code>window.location = url</code>跳转指定链接，跳转时可在链接后添加参数，如：<code>window.location = &quot;movie-details.html?id=$123&quot;</code>,还可以用<code>window.location.href</code>获得当前页面的链接。如果要向<code>url</code>添加的参数为中文，则应先将中文编码，再添加至<code>url</code>,要获取该参数，获取后再解码即可。如，使用<code>encodeURI()</code>编码中文，使用<code>decodeURI()</code>解码。</p>
<h2 id="三圈"><a href="#三圈" class="headerlink" title="三圈"></a>三圈</h2><p>上周有元旦假期，这周相比上周当然是处于学习圈了。但是这周不是简单的代码练习，而是有两个小项目，其中一个还要合作完成，虽然比较忙，但是完成之后看着这两个小项目，还是很开心的，小有成就感233.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/13/summary_week5_2/" data-id="cjr3nsryy000dh4owv3dlhcqo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-summary_week3_2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/29/summary_week3_2/" class="article-date">
  <time datetime="2018-12-29T14:10:59.401Z" itemprop="datePublished">2018-12-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/29/summary_week3_2/">总结—JS进阶第三周</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习和反思"><a href="#学习和反思" class="headerlink" title="学习和反思"></a>学习和反思</h2><p>这周前半周主要在做ES6的运算合集和复习前面的知识。运算合集这是之前做过的，没有遇到什么问题。复习方面，周五的小问题环节，我发现我真是严格按照考察表复习的…有些东西考察表上虽然没写，但是是最基本的，还是要好好复习啊..譬如引入CSS的方法，我只是记住了有三种，以及它们大概的内容…在后面的复习中对于一些最基本的内容，比如定义什么的，还是要记清楚。<br>后两天就是在做打印成绩单任务卡，也是了解感受了测试驱动开发，任务卡还没完成，做得过程太粗心了，花了些多余的时间。对于打印提示的main()的测试代码，还没想好怎么写。</p>
<h2 id="三圈"><a href="#三圈" class="headerlink" title="三圈"></a>三圈</h2><p>时间过得好快，也感觉不出来是什么圈…相比上周的舒适圈的话，这周算处于学习圈吧，因为这周的打印成绩单还挺难的，上周的任务卡就比较简单了，自己一个人就做得来。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/29/summary_week3_2/" data-id="cjr3nsrya000ah4owp8otfjxa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-summary_week2_2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/23/summary_week2_2/" class="article-date">
  <time datetime="2018-12-23T12:58:00.509Z" itemprop="datePublished">2018-12-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/23/summary_week2_2/">总结—JS进阶第二周</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>这周的新内容是ES6和面向对象。</p>
<p>ES6新特性中中目前在写代码中使用较多的是<code>let</code>,<code>const</code>，模板字符串和箭头函数，其他内容处于了解阶段。</p>
<p>面向对象任务卡了解了什么是面向对象，其最主要的特质是<strong>封装</strong>，<strong>继承</strong>，<strong>多态</strong>，以及面向对象编程的优点。加下线下学习的内容，了解了想要创建一个指定类型的对象时可以用创建函数法和对象原型，以及两者兼有的方法，ES6还提供了更简洁的方法，类<code>class</code>。</p>
<h2 id="三圈"><a href="#三圈" class="headerlink" title="三圈"></a>三圈</h2><p>这周相比于上周我处在<strong>舒适圈</strong>，主要原因是这周的任务少，比较轻松。不过这周别的事情也不少，去学校联系毕设呀，和快回家的同学吃饭聚会呀，年会呀，和考研的朋友谈心呀，果真是不管任务多少，都能拖拖拉拉做一个礼拜啊…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/23/summary_week2_2/" data-id="cjr3nsry40009h4owi27egmx4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-summary_week1_2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/15/summary_week1_2/" class="article-date">
  <time datetime="2018-12-15T12:09:03.157Z" itemprop="datePublished">2018-12-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/15/summary_week1_2/">总结—JavaScript进阶第一周</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><p>这周的新内容是了解了node.js和npm：</p>
<ul>
<li>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。</li>
<li>NPM（node package manager)，是基于couchdb的一个数据库，通常称为node包管理器，主要功能就是管理node包，包括：安装、卸载、更新、查看、搜索、发布等。NPM详细记录了每个包的信息（作者、版本、依赖、授权信息等）。</li>
</ul>
<p>其次这周主要是做了大量JS数组、字符串、对象方法的练习，经过大量的练习，我对JS数组等方法有了更深的理解，也不再像以前一样总是倾向于使用<code>for</code>循环等语句来编写代码。</p>
<p>这周还有一个任务就是复习Tasking,完成“黄焖鸡”，做好任务分解后，再来写代码确实要简单快捷许多。</p>
<h2 id="三圈"><a href="#三圈" class="headerlink" title="三圈"></a>三圈</h2><p>这周相比于上周，我觉得自己处于<strong>学习圈</strong>。这周学习的内容本身不难，主要是任务量比较大。运算合集的题还挺多的，我也做了挺长时间，但是不得不说全部做完了之后还是很开心的！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/15/summary_week1_2/" data-id="cjr3nsrxo0007h4ow9rca0vmq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-notes_of_advanced_js" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/09/notes_of_advanced_js/" class="article-date">
  <time datetime="2018-12-09T10:37:53.798Z" itemprop="datePublished">2018-12-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/09/notes_of_advanced_js/">JavaScript进阶笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><ul>
<li><code>Node.js</code>概述<ul>
<li><code>Node.js</code> 是一个基于 Chrome V8 引擎的 <code>JavaScript</code> 运行环境。</li>
<li><code>Node.js</code> 使用了一个事件驱动、非阻塞式 <code>I/O</code> 的模型，使其轻量又高效。</li>
<li><code>Node.js</code> 的包管理器 <code>npm</code>，是全球最大的开源库生态系统。</li>
</ul>
</li>
<li><code>Node.js</code>特点<ul>
<li>使用的是为Google Chrome提供动力的V8虚拟机。V8让node在性能上得到巨大的提升，因为它去掉了中间环节，执行的不是字节码，用的也不是解释器，而是直接编译成了本地机器码。</li>
<li><code>JavaScript</code>语言</li>
<li>事件驱动，非阻塞式<code>I/O</code></li>
<li>使用 <code>npm</code> 来管理包</li>
</ul>
</li>
<li>使用<code>node</code>运行<code>js</code>文件：<ul>
<li>交互模式（连按两次<code>Ctrl+C</code>退出交互模式）</li>
<li>命令行模式</li>
</ul>
</li>
</ul>
<h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><ul>
<li>NPM是什么？<br>NPM（node package manager)，通常称为node包管理器，主要功能就是管理node包，包括：安装、卸载、更新、查看、搜索、发布等。NPM是基于couchdb一个数据库，详细记录了每个包的信息（作者、版本、依赖、授权信息等）。它是世界上最大的软件注册表，每星期大约有 30 亿次的下载量，包含超过 600000 个 包（package） （即，代码模块）。来自各大洲的开源软件开发者使用 npm 互相分享和借鉴。包的结构使您能够轻松跟踪依赖项和版本。</li>
<li>NPM的作用<ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
</ul>
</li>
<li>NPM常用命令<ul>
<li><code>npm -v</code>：查看npm版本号</li>
<li><code>npm init</code>: 初始化项目</li>
<li><code>npm install module</code>:本地安装需要的模块module</li>
<li><code>npm install module -g</code>:全局安装需要的模块module</li>
<li>在<code>package.json</code>文件的<code>dependencies</code>块下或通过<code>npm ls</code>命令查看当前项目下依赖的包</li>
<li><code>npm uninstall module</code>：卸载模块</li>
<li><code>npm update module</code>：更新模块</li>
<li><code>npm search module</code>:搜索模块</li>
<li><code>npm help &lt;command&gt;</code>:查看某条命令的详细帮助</li>
</ul>
</li>
</ul>
<h2 id="ECMAScript-6"><a href="#ECMAScript-6" class="headerlink" title="ECMAScript 6"></a>ECMAScript 6</h2><ul>
<li>ECMAScript 6 简介：<ul>
<li>ECMAScript(ES6) 是JavaScript语言的下一代标准，已经在2015年6月正式发布了；在 JavaScript 的基础上做了重大的更新，提供了更优雅的语法和特性。</li>
</ul>
</li>
<li>ECMAScript 和 JavaScript 的关系<ul>
<li>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。名字不同的原因：<ol>
<li>商标，1996年11月，JavaScript的创造者Netscape公司，决定将JavaScript提交给国际标准化组织ECMA，希望这种语言能够成为国际标准。根据授权协议，只有Netscape公司(Javascript 的创造者)可以合法地使用JavaScript这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标</li>
<li>想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</li>
</ol>
</li>
</ul>
</li>
<li>块级作用域</li>
</ul>
<h4 id="没有块级作用域，会带来很多不合理的场景。如："><a href="#没有块级作用域，会带来很多不合理的场景。如：" class="headerlink" title="没有块级作用域，会带来很多不合理的场景。如："></a>没有块级作用域，会带来很多不合理的场景。如：</h4><ul>
<li>第一种场景，内层变量可能会覆盖外层变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var tmp = new Date();</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(tmp);</span><br><span class="line">  if (false) &#123;</span><br><span class="line">    var tmp = &apos;hello world&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); // undefined</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>函数<code>f</code>执行后，输出结果为<code>undefined</code>，原因在于<code>if</code>内的<code>tmp</code>用<code>var</code>声明，在全局范围内有效，导致内层的tmp变量覆盖了外层的tmp变量，变量提升，输出语句写在<code>tmp</code>声明语句之前，输出<code>undefined</code>。</p>
<ul>
<li>第二种场景，用来计数的循环变量泄露为全局变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = &apos;hello&apos;;</span><br><span class="line"></span><br><span class="line">for (var i = 0; i &lt; s.length; i++) &#123;</span><br><span class="line">  console.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i); // 5</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码中，变量<code>i</code>只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
<p>为了避免这些不合理的场景，ES6通过<code>let</code>和<code>const</code>增加了块级作用域。<code>let</code> 和 <code>const</code> 只在于当前的块作用域中有效，而 <code>var</code> 声明的变量是在函数作用域内有效。<code>const</code> 和 <code>let</code> 的区别则在于， <code>const</code> 声明变量的同时必须立即给一个初始值，且无法在对该值进行修改。如果该初始值是一个对象，那么该对象的值是可以被修改的。</p>
<h4 id="有块级作用域后："><a href="#有块级作用域后：" class="headerlink" title="有块级作用域后："></a>有块级作用域后：</h4><ul>
<li><p>ES6 允许块级作用域的任意嵌套。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123;let insane = &apos;Hello World&apos;&#125;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>外层作用域无法读取内层作用域的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;let insane = &apos;Hello World&apos;&#125;</span><br><span class="line">  console.log(insane); // 报错</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内层作用域可以定义外层作用域的同名变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  let insane = &apos;Hello World&apos;;</span><br><span class="line">  &#123;let insane = &apos;Hello World&apos;&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>let</code>不允许在相同作用域内，重复声明同一个变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">function func() &#123;</span><br><span class="line">  let a = 10;</span><br><span class="line">  var a = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 报错</span><br><span class="line">function func() &#123;</span><br><span class="line">  let a = 10;</span><br><span class="line">  let a = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在块级作用域内，使用<code>let</code>命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  // TDZ开始</span><br><span class="line">  tmp = &apos;abc&apos;; // ReferenceError</span><br><span class="line">  console.log(tmp); // ReferenceError</span><br><span class="line"></span><br><span class="line">  let tmp; // TDZ结束</span><br><span class="line">  console.log(tmp); // undefined</span><br><span class="line"></span><br><span class="line">  tmp = 123;</span><br><span class="line">  console.log(tmp); // 123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>块级作用域与函数声明</p>
</li>
</ul>
<p>ES6 规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。但是为了减轻对老代码的影响，，ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。</p>
<ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<p>根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于<code>var</code>声明的变量。考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 函数声明语句</span><br><span class="line">&#123;</span><br><span class="line">  let a = &apos;secret&apos;;</span><br><span class="line">  function f() &#123;</span><br><span class="line">    return a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 函数表达式</span><br><span class="line">&#123;</span><br><span class="line">  let a = &apos;secret&apos;;</span><br><span class="line">  let f = function () &#123;</span><br><span class="line">    return a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p>
<ul>
<li>变量的解构赋值</li>
</ul>
<p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<ul>
<li><p>数组的解构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let [foo, [[bar], baz]] = [1, [[2], 3]];</span><br><span class="line">foo // 1</span><br><span class="line">bar // 2</span><br><span class="line">baz // 3</span><br><span class="line"></span><br><span class="line">let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];</span><br><span class="line">third // &quot;baz&quot;</span><br><span class="line"></span><br><span class="line">let [x, , y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 3</span><br><span class="line"></span><br><span class="line">let [head, ...tail] = [1, 2, 3, 4];</span><br><span class="line">head // 1</span><br><span class="line">tail // [2, 3, 4]</span><br><span class="line"></span><br><span class="line">let [x, y, ...z] = [&apos;a&apos;];</span><br><span class="line">x // &quot;a&quot;</span><br><span class="line">y // undefined</span><br><span class="line">z // []</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果解构不成功，变量的值就等于undefined。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let [foo] = [];</span><br><span class="line">let [bar, foo] = [1];</span><br></pre></td></tr></table></figure>
</li>
<li><p>不完全解构：等号左边的模式，只匹配一部分的等号右边的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let [x, y] = [1, 2, 3];</span><br><span class="line">x // 1</span><br><span class="line">y // 2</span><br><span class="line"></span><br><span class="line">let [a, [b], d] = [1, [2, 3], 4];</span><br><span class="line">a // 1</span><br><span class="line">b // 2</span><br><span class="line">d // 4</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line">let [foo] = 1;</span><br><span class="line">let [foo] = false;</span><br><span class="line">let [foo] = NaN;</span><br><span class="line">let [foo] = undefined;</span><br><span class="line">let [foo] = null;</span><br><span class="line">let [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>对象的解构</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">foo // &quot;aaa&quot;</span><br><span class="line">bar // &quot;bbb&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let &#123; bar, foo &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">foo // &quot;aaa&quot;</span><br><span class="line">bar // &quot;bbb&quot;</span><br><span class="line"></span><br><span class="line">let &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">baz // undefined</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123; foo: baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;</span><br><span class="line">baz // &quot;aaa&quot;</span><br><span class="line">foo // error: foo is not defined</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>字符串的解构赋值<br>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const [a, b, c, d, e] = &apos;hello&apos;;</span><br><span class="line">a // &quot;h&quot;</span><br><span class="line">b // &quot;e&quot;</span><br><span class="line">c // &quot;l&quot;</span><br><span class="line">d // &quot;l&quot;</span><br><span class="line">e // &quot;o&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>字符串拓展</p>
<ul>
<li>模版字符串</li>
</ul>
<p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串（所有的空格和缩进都会被保留在输出之中），或者在字符串中嵌入变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 普通字符串</span><br><span class="line">`In JavaScript &apos;\n&apos; is a line-feed.`</span><br><span class="line"></span><br><span class="line">// 多行字符串</span><br><span class="line">`In JavaScript this is</span><br><span class="line">not legal.`</span><br><span class="line"></span><br><span class="line">console.log(`string text line 1</span><br><span class="line">string text line 2`);</span><br><span class="line"></span><br><span class="line">// 字符串中嵌入变量</span><br><span class="line">let name = &quot;Bob&quot;, time = &quot;today&quot;;</span><br><span class="line">`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`</span><br></pre></td></tr></table></figure>
<p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let greeting = `\`Yo\` World!`;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数的扩展</p>
<ul>
<li><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function log(x, y = &apos;World&apos;) &#123;</span><br><span class="line">  console.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(&apos;Hello&apos;) // Hello World</span><br><span class="line">log(&apos;Hello&apos;, &apos;China&apos;) // Hello China</span><br><span class="line">log(&apos;Hello&apos;, &apos;&apos;) // Hello</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6 引入 <code>rest</code> 参数（形式为…变量名），用于获取函数的多余参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function example(...values)&#123;</span><br><span class="line">    console.log(values)// console: [1,2,3,4]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example(1,2,3,4) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var a = [1,2,3]</span><br><span class="line"></span><br><span class="line">var b = [...a,4,5,6] //b = [1,2,3,4,5,6]</span><br></pre></td></tr></table></figure>
</li>
<li><p>箭头函数</p>
<ul>
<li><p>ES6 允许使用“箭头”（=&gt;）定义函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var f = v =&gt; v;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">var f = function (v) &#123;</span><br><span class="line">  return v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f = () =&gt; 5;</span><br><span class="line">// 等同于</span><br><span class="line">var f = function () &#123; return 5 &#125;;</span><br><span class="line"></span><br><span class="line">var sum = (num1, num2) =&gt; num1 + num2;</span><br><span class="line">// 等同于</span><br><span class="line">var sum = function(num1, num2) &#123;</span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果箭头函数的函数体只包含一行代码，则可以不需要写大括号以及 return 语句返回（如果有返回值）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var sum = (num1,num2) =&gt; num1+num2</span><br><span class="line">等同于</span><br><span class="line">var sum = (num1,num2) =&gt; &#123;return num1+num2&#125;</span><br><span class="line">等同于</span><br><span class="line">var sum = function(num1,num2)&#123;return num1+num2&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul>
<li>面向对象编程：<br>把一组数据结构和处理它们的方法组成<strong>对象</strong>(Object), 把相同行为的对象归纳为<strong>类</strong>(Class), 通过类的<strong>封装</strong>(encapsulation)隐藏内部细节，通过<strong>继承</strong>(inheritance)实现类的<strong>特化</strong>(specializetion)/<strong>泛化</strong>(generalization), 通过<strong>多态</strong>(polymorphism)实现基于对象类型的<strong>动态分派</strong>。其实就是我们按照正常的思维去写程序，我们会将现实世界中的东西视为一个个对象，然后他们的行为就是一个个方法。<br><img src="https://pic1.zhimg.com/80/664ba37eeee9f4623c06c066867f1d38_hd.jpg" alt=""></li>
<li>面向对象这个<strong>对象</strong>，指的是客体。所谓客体是指客观存在的对象实体和主观抽象的概念。 </li>
<li>面向对象的好处？<ol>
<li>接近人的思维，符合人类对现实世界的认知；</li>
<li>封装特性可以使开发者不必在意内部的具体实现，更方便互相协作；</li>
<li>继承特性可以减少代码冗余，实现代码复用；</li>
<li>多态特性令子类相比父类有不同的行为，这是非常接近现实的。</li>
</ol>
</li>
<li>面向对象是为了解决系统的<strong>可维护性</strong>，<strong>可扩展性</strong>，<strong>可重用性</strong>。<ul>
<li>面向对象的三大特征： <ul>
<li>封装：找到变化并且把它封装起来。封装的作用，就解决了程序的可扩展性。 </li>
<li>继承：子类继承父类，可以继承父类的方法及属性，实现了多态以及代码的重用，因此也解决了系统的重用性和扩展性，但是继承破坏了封装，因为他是对子类开放的，修改父类会导致所有子类的改变，因此继承一定程度上又破坏了系统的可扩展性，所以继承需要慎用。</li>
<li>多态：接口的多种不同的实现方式即为多态。</li>
</ul>
</li>
</ul>
</li>
<li>面对对象编程三大步骤：<ul>
<li>面向对象的分析(OOA)：分析需求，先不要思考怎么用程序实现它，先分析需求中稳定不变的客体都是些什么，这些客体之间的关系是什么。</li>
<li>面向对象的设计(OOD)：把第一步分析出来的需求，通过进一步扩充模型，变成可实现的、符合成本的、模块化的、低耦合高内聚的模型。</li>
<li>面向对象的编程实现(OOP)：使用面向对象的实现模型 。</li>
</ul>
</li>
<li>面向对象和基于对象的区别<br>“面向对象”和“基于对象”都实现了“封装”的概念，但是面向对象实现了“继承和多态”，而“基于对象”没有实现这些</li>
</ul>
<h3 id="1-生成实例对象的原始模式-字面量"><a href="#1-生成实例对象的原始模式-字面量" class="headerlink" title="1.生成实例对象的原始模式,字面量"></a>1.生成实例对象的原始模式,字面量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　var Cat = &#123;</span><br><span class="line">　　　　name : &apos;&apos;,</span><br><span class="line"></span><br><span class="line">　　　　color : &apos;&apos;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>根据这个原型对象的规格（schema），生成两个实例对象:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　var cat1 = &#123;&#125;; // 创建一个空对象</span><br><span class="line"></span><br><span class="line">　　　　cat1.name = &quot;大毛&quot;; // 按照原型对象的属性赋值</span><br><span class="line"></span><br><span class="line">　　　　cat1.color = &quot;黄色&quot;;</span><br><span class="line"></span><br><span class="line">　　var cat2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">　　　　cat2.name = &quot;二毛&quot;;</span><br><span class="line"></span><br><span class="line">　　　　cat2.color = &quot;黑色&quot;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这样的写法有两个缺点<ul>
<li>一是如果多生成几个实例，写起来就非常麻烦；</li>
<li>二是实例与原型之间，没有任何办法，可以看出有什么联系。</li>
</ul>
</li>
</ul>
<h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name,color) &#123;</span><br><span class="line"></span><br><span class="line">　　　　return &#123;</span><br><span class="line"></span><br><span class="line">　　　　　　name:name,</span><br><span class="line"></span><br><span class="line">　　　　　　color:color</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<p>然后生成实例对象，就等于是在调用函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　var cat1 = Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class="line"></span><br><span class="line">　　var cat2 = Cat(&quot;二毛&quot;,&quot;黑色&quot;);</span><br></pre></td></tr></table></figure></p>
<p>这种方法的问题依然是，cat1和cat2之间没有内在的联系，不能反映出它们是同一个原型对象的实例。</p>
<h3 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3.构造函数"></a>3.构造函数</h3><p>“构造函数”，其实就是一个普通函数，但是内部使用了this变量。对构造函数使用new运算符，就能生成实例，并且this变量会绑定在实例对象上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　function Cat(name,color)&#123;</span><br><span class="line"></span><br><span class="line">　　　　this.name=name;</span><br><span class="line"></span><br><span class="line">　　　　this.color=color;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成实例对象了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">　　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class="line"></span><br><span class="line">　　var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);</span><br><span class="line"></span><br><span class="line">　　alert(cat1.name); // 大毛</span><br><span class="line"></span><br><span class="line">　　alert(cat1.color); // 黄色</span><br></pre></td></tr></table></figure></p>
<p><code>instanceof</code>运算符，验证原型对象与实例对象之间的关系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　alert(cat1 instanceof Cat); //true</span><br><span class="line"></span><br><span class="line">　　alert(cat2 instanceof Cat); //true</span><br></pre></td></tr></table></figure></p>
<p>构造函数方法存在浪费内存的问题,生成示例时，对象内的方法和属性都是指向不同的内存地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(cat1.eat == cat2.eat); //false</span><br></pre></td></tr></table></figure></p>
<h3 id="4-prototype模式"><a href="#4-prototype模式" class="headerlink" title="4.prototype模式"></a>4.prototype模式</h3><p>Javascript规定，每一个构造函数都有一个<code>prototype</code>属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。</p>
<p>这意味着，我们可以把那些不变的属性和方法，直接定义在<code>prototype</code>对象上。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">　　function Cat(name,color)&#123;</span><br><span class="line"></span><br><span class="line">　　　　this.name = name;</span><br><span class="line"></span><br><span class="line">　　　　this.color = color;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　Cat.prototype.type = &quot;猫科动物&quot;;</span><br><span class="line"></span><br><span class="line">　　Cat.prototype.eat = function()&#123;alert(&quot;吃老鼠&quot;)&#125;;</span><br></pre></td></tr></table></figure></p>
<p>生成实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　var cat1 = new Cat(&quot;大毛&quot;,&quot;黄色&quot;);</span><br><span class="line"></span><br><span class="line">　　var cat2 = new Cat(&quot;二毛&quot;,&quot;黑色&quot;);</span><br><span class="line"></span><br><span class="line">　　alert(cat1.type); // 猫科动物</span><br><span class="line"></span><br><span class="line">　　cat1.eat(); // 吃老鼠</span><br><span class="line"></span><br><span class="line">　　alert(cat1.eat == cat2.eat); //true</span><br></pre></td></tr></table></figure></p>
<p>prototype模式的缺点在于给实例添加或删除属性和方法时，原型的属性和方法也会添加或删除。所以，可以结合构造函数和prototype模式。</p>
<h3 id="5-class"><a href="#5-class" class="headerlink" title="5.class"></a>5.class</h3><p>ES6 引入了 Class（类）这个概念，作为对象的模板。通过<code>class</code>关键字，可以定义类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x = x;</span><br><span class="line">    this.y = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类的数据类型就是函数，类本身就指向构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof Point // &quot;function&quot;</span><br><span class="line">Point === Point.prototype.constructor // true</span><br></pre></td></tr></table></figure></p>
<p>使用实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Bar &#123;</span><br><span class="line">  doStuff() &#123;</span><br><span class="line">    console.log(&apos;stuff&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var b = new Bar();</span><br><span class="line">b.doStuff() // &quot;stuff&quot;</span><br></pre></td></tr></table></figure></p>
<p>类的所有方法都定义在类的<code>prototype</code>属性上面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toValue() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line"></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  constructor() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;,</span><br><span class="line">  toValue() &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>Object.assign</code>方法可以很方便地一次向类添加多个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor()&#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object.assign(Point.prototype, &#123;</span><br><span class="line">  toString()&#123;&#125;,</span><br><span class="line">  toValue()&#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    super(x, y); // 调用父类的constructor(x, y)</span><br><span class="line">    this.color = color;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    return this.color + &apos; &apos; + super.toString(); // 调用父类的toString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。</p>
<p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/09/notes_of_advanced_js/" data-id="cjr3nss22000lh4ow81h8fjl7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/19/summary_of_exam/">测评总结与反思</a>
          </li>
        
          <li>
            <a href="/2019/01/16/single_responsibility_principle/">单一职责原则</a>
          </li>
        
          <li>
            <a href="/2019/01/16/notes_of_java_foundation/">Java基础语法笔记</a>
          </li>
        
          <li>
            <a href="/2019/01/15/IntelliJ-IDEA-Tutorial/">初级IntelliJ IDEA使用总结</a>
          </li>
        
          <li>
            <a href="/2019/01/14/jvm_jre_jdk/">JVM, JRE, JDK 的区别和联系</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Song Nan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>